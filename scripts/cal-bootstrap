#!/bin/zsh

set -e

# Get script directory (works in zsh)
SCRIPT_DIR="${0:A:h}"

# CAL Bootstrap Script
# Usage: ./cal-bootstrap [--init|-i] [--run] [--restart|-r] [--gui|-g] [--stop] [--status|-s] [--snapshot|-S <action> <name>]
#
# Options:
#   --init, -i      Initialize VM environment (create cal-clean, cal-dev, cal-init)
#   --run           Run cal-dev and SSH in with tmux (default if VMs exist)
#   --restart, -r   Restart cal-dev and SSH in with tmux
#   --gui, -g       Launch cal-dev with VNC GUI (experimental mode with clipboard support)
#   --stop          Stop cal-dev
#   --status, -s    Show VM status and connection info
#   --snapshot, -S  Manage snapshots (list, create, restore, delete)
#   --yes, -y       Skip confirmation prompts
#
# Environment variables:
#   TART_PATH       - Path to tart binary
#   VM_USER         - VM username (default: admin)
#   VM_PASSWORD     - VM password (default: admin)

# VM names
VM_CLEAN="cal-clean"
VM_DEV="cal-dev"
VM_INIT="cal-init"

# VM credentials
VM_USER="${VM_USER:-admin}"
VM_PASSWORD="${VM_PASSWORD:-admin}"

# Host user for transparent proxy tunnel (the user running this script)
HOST_USER="${HOST_USER:-$(whoami)}"

# Transparent proxy settings (configurable via environment)
# Uses sshuttle for truly transparent network routing - no app configuration needed
PROXY_MODE="${PROXY_MODE:-auto}"  # on, off, or auto (default)
HOST_GATEWAY="${HOST_GATEWAY:-192.168.64.1}"

# Package download cache (temporary for this script only, does not affect host system)
# Downloads during --init will be cached and reused by VM
if [ -d "$HOME/.cal-cache" ]; then
    export HOMEBREW_CACHE="$HOME/.cal-cache/homebrew"
    export npm_config_cache="$HOME/.cal-cache/npm"
    export GOMODCACHE="$HOME/.cal-cache/go"
fi

# Log file for debugging
CAL_LOG="${HOME}/.cal-bootstrap.log"

# Cleanup tracking
CLEANUP_VM=false
CLEANUP_DONE=false
CLEANUP_DELETE_CALDEV=false
TART_PID=""

# Force delete flag (skip git checks and avoid booting)
FORCE_DELETE=false

# Cleanup function
cleanup() {
    if [ "$CLEANUP_DONE" = true ]; then
        return
    fi
    CLEANUP_DONE=true
    
    if [ "$CLEANUP_VM" = true ] && [ -n "$TART_PID" ] && kill -0 "$TART_PID" 2>/dev/null; then
        echo ""
        echo "Cleaning up background VM process (PID: $TART_PID)..."
        kill "$TART_PID" 2>/dev/null || true
        wait "$TART_PID" 2>/dev/null || true
    fi
    
    # Delete cal-dev if init failed (leaves incomplete/unstable VM)
    if [ "$CLEANUP_DELETE_CALDEV" = true ]; then
        echo ""
        echo "ðŸ—‘ï¸  Cleaning up incomplete VM..."
        "$TART" stop "$VM_DEV" 2>/dev/null || true
        sleep 1
        if "$TART" delete "$VM_DEV" 2>/dev/null; then
            echo "  âœ“ Deleted $VM_DEV (incomplete initialization)"
        fi
    fi
}

# Handle Ctrl-C properly
handle_interrupt() {
    echo ""
    echo "Interrupted by user"
    cleanup
    exit 130
}

trap cleanup EXIT
trap handle_interrupt INT TERM

# Find tart binary
find_tart() {
    if command -v tart &>/dev/null; then
        echo "tart"
    elif [ -n "$TART_PATH" ] && [ -x "$TART_PATH" ]; then
        echo "$TART_PATH"
    elif [ -x "./tart.app/Contents/MacOS/tart" ]; then
        echo "./tart.app/Contents/MacOS/tart"
    else
        echo ""
    fi
}

# Check if VM exists
vm_exists() {
    "$TART" list 2>/dev/null | awk -v vm="$1" 'NR>1 { if ($2 == vm) { found=1; exit } } END { if (found) exit 0; else exit 1 }'
}

# Resolve VM name (short name to full name if needed)
resolve_vm_name() {
    local input_name="$1"
    
    # If VM exists with exact name, use it
    if vm_exists "$input_name"; then
        echo "$input_name"
        return 0
    fi
    
    # Try to find by short name pattern
    local matches
    matches=$("$TART" list 2>/dev/null | awk -v short="$input_name" '
        NR==1 {next}
        {
            full_name = $2
            source = $1
            
            # Create short name
            short_name = full_name
            if (source == "OCI") {
                gsub(/ghcr.io\/cirruslabs\/macos-/, "", short_name)
                if (match(short_name, /@sha256:/)) {
                    short_name = substr(short_name, 1, RSTART-1) "-digest"
                }
            }
            
            # Match short name
            if (short_name == short) {
                print full_name
            }
        }
    ')
    
    # Check for multiple matches (collision)
    local match_count
    match_count=$(echo "$matches" | grep -c '^' 2>/dev/null || echo 0)
    
    if [ "$match_count" -gt 1 ]; then
        echo "Error: Short name '$input_name' matches multiple VMs:" >&2
        echo "$matches" | sed 's/^/  - /' >&2
        echo "" >&2
        echo "Use full name instead." >&2
        return 2
    elif [ "$match_count" -eq 1 ]; then
        echo "$matches"
        return 0
    fi
    
    # Not found
    return 1
}

# Check if VM is running
vm_running() {
    "$TART" list 2>/dev/null | awk -v vm="$1" 'NR>1 { if ($2 == vm && $NF == "running") { found=1; exit } } END { if (found) exit 0; else exit 1 }'
}

# Stop VM if running
stop_vm() {
    local vm="$1"
    if vm_running "$vm"; then
        echo "  Stopping $vm..."
        "$TART" stop "$vm" 2>/dev/null || true
        sleep 2
    fi
}

# Save tmux sessions before stopping VM
save_tmux_sessions() {
    local vm="$1"

    # Only save if VM is running
    if ! vm_running "$vm"; then
        return 0
    fi

    # Get VM IP
    local vm_ip
    vm_ip=$("$TART" ip "$vm" 2>/dev/null || echo "")

    if [ -z "$vm_ip" ]; then
        echo "  âš  Could not get VM IP to save tmux sessions"
        return 0  # Non-fatal
    fi

    echo "  Saving tmux sessions..."

    # SSH and trigger synchronous tmux save using display-message (blocks until complete)
    # Use full path to tmux since Homebrew isn't in PATH for non-login shells
    save_result=$(ssh -o ConnectTimeout=5 \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        "$VM_USER@$vm_ip" \
        "/opt/homebrew/bin/tmux run-shell -b '~/.tmux/plugins/tmux-resurrect/scripts/save.sh'; sleep 0.5; echo done" 2>&1)

    if echo "$save_result" | grep -q "done"; then
        echo "  âœ“ Tmux sessions saved"
    else
        echo "  âš  Could not save tmux sessions: $save_result"
    fi
}

# Start VM in background and wait for IP/SSH
start_vm_background() {
    local vm="$1"
    local share_tart_cache="${2:-true}"  # Default to sharing cache

    echo "  Starting $vm in background..."

    # Build tart run command with optional cache sharing
    local tart_cmd=("$TART" "run" "--no-graphics")

    # Share host's Tart cache with VM (read-only) to avoid duplicate downloads
    # when running nested VMs. Mounted to /Volumes/My Shared Files/tart-cache
    if [ "$share_tart_cache" = "true" ] && [ -d ~/.tart/cache ]; then
        tart_cmd+=("--dir" "tart-cache:${HOME}/.tart/cache:ro,tag=com.apple.virtio-fs.automount")
    fi

    # Share host's package cache with VM (read-write) for Homebrew, npm, Go, Git caches
    # Mounted to /Volumes/My Shared Files/cal-cache
    if [ -d ~/.cal-cache ]; then
        tart_cmd+=("--dir" "cal-cache:${HOME}/.cal-cache:rw,tag=com.apple.virtio-fs.automount")
    fi

    tart_cmd+=("$vm")

    "${tart_cmd[@]}" >/dev/null 2>&1 &
    TART_PID=$!
    disown "$TART_PID" 2>/dev/null || true
    CLEANUP_VM=true
    echo "  VM started (PID: $TART_PID)"
    
    # Wait for IP
    echo "  Waiting for IP..."
    local max_wait=60
    local count=0
    VM_IP=""
    
    while [ $count -lt $max_wait ]; do
        sleep 2
        count=$((count + 2))
        VM_IP=$("$TART" ip "$vm" 2>/dev/null || echo "")
        if [ -n "$VM_IP" ]; then
            echo "  VM IP: $VM_IP"
            break
        fi
        printf "  Waiting... (%ds/%ds)\r" "$count" "$max_wait"
    done
    
    if [ -z "$VM_IP" ]; then
        echo "  Could not obtain IP after ${max_wait}s"
        return 1
    fi
    
    # Wait for SSH
    echo "  Waiting for SSH..."
    
    # Ensure sshpass is available for automated setup (install quietly if needed)
    if ! command -v sshpass &>/dev/null; then
        # Try to install sshpass silently
        brew install esolitos/ipa/sshpass &>/dev/null 2>&1 || \
        brew install hudochenkov/sshpass/sshpass &>/dev/null 2>&1 || true
    fi
    
    local has_sshpass=false
    local has_expect=false
    if command -v sshpass &>/dev/null; then
        has_sshpass=true
    elif command -v expect &>/dev/null; then
        has_expect=true
    fi
    
    count=0
    
    while [ $count -lt $max_wait ]; do
        if [ "$has_sshpass" = true ]; then
            # With sshpass: try automated password auth
            if SSHPASS="${VM_PASSWORD}" sshpass -e ssh -o ConnectTimeout=2 -o StrictHostKeyChecking=no \
                   -o UserKnownHostsFile=/dev/null -o PreferredAuthentications=password \
                   "${VM_USER}@${VM_IP}" "echo ok" &>/dev/null 2>&1; then
                echo "  SSH is ready"
                return 0
            fi
        elif [ "$has_expect" = true ]; then
            # With expect: try automated password auth
            if expect -c "
                set timeout 5
                spawn ssh -o ConnectTimeout=2 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${VM_USER}@${VM_IP} echo ok
                expect {
                    \"*assword*\" { send \"${VM_PASSWORD}\r\"; exp_continue }
                    \"ok\" { exit 0 }
                    timeout { exit 1 }
                    eof { exit 1 }
                }
            " &>/dev/null 2>&1; then
                echo "  SSH is ready"
                return 0
            fi
        else
            # Without sshpass or expect: check if SSH port is open
            if nc -z -w 2 "$VM_IP" 22 &>/dev/null; then
                echo "  SSH is ready"
                return 0
            fi
        fi
        sleep 2
        count=$((count + 2))
        printf "  Waiting for SSH... (%ds/%ds)\r" "$count" "$max_wait"
    done
    
    echo "  SSH not available after ${max_wait}s"
    return 1
}

# Setup SSH keys
setup_ssh_keys() {
    local vm_ip="$1"
    
    echo "  Checking SSH keys..."
    
    # Check if SSH key exists
    if [ ! -f ~/.ssh/id_rsa.pub ] && [ ! -f ~/.ssh/id_ed25519.pub ]; then
        echo "  No SSH key found. Generating..."
        ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519 -N "" -q
        echo "  SSH key generated"
    fi
    
    # Test if key auth already works
    if ssh -o BatchMode=yes -o ConnectTimeout=2 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${vm_ip}" "echo ok" &>/dev/null; then
        echo "  SSH key authentication already configured"
        return 0
    fi
    
    # Copy SSH key using sshpass for automation (silently)
    echo "  Copying SSH key to VM..."
    
    # Ensure sshpass or expect is available
    if ! command -v sshpass &>/dev/null; then
        brew install esolitos/ipa/sshpass &>/dev/null 2>&1 || \
        brew install hudochenkov/sshpass/sshpass &>/dev/null 2>&1 || true
    fi
    
    # Get public key
    local pubkey
    if [ -f ~/.ssh/id_ed25519.pub ]; then
        pubkey=$(cat ~/.ssh/id_ed25519.pub)
    else
        pubkey=$(cat ~/.ssh/id_rsa.pub)
    fi
    
    if command -v sshpass &>/dev/null; then
        # Use sshpass for automated key copy
        SSHPASS="${VM_PASSWORD}" sshpass -e ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "${VM_USER}@${vm_ip}" \
            "mkdir -p ~/.ssh && echo '$pubkey' >> ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys" &>/dev/null
    elif command -v expect &>/dev/null; then
        # Use expect as fallback (usually pre-installed on macOS)
        expect -c "
            set timeout 30
            spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${VM_USER}@${vm_ip} {mkdir -p ~/.ssh && echo '$pubkey' >> ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys}
            expect {
                \"*assword*\" { send \"${VM_PASSWORD}\r\"; exp_continue }
                eof
            }
        " &>/dev/null
    else
        # Last resort: manual password entry
        echo "  âš ï¸  Automated setup unavailable - password: ${VM_PASSWORD}"
        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "${VM_USER}@${vm_ip}" \
            "mkdir -p ~/.ssh && echo '$pubkey' >> ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys"
    fi
    
    echo "  SSH key copied"
}

# Start bootstrap SOCKS proxy (SSH -D tunnel, no extra packages needed)
# Used during --init before sshuttle is installed
start_bootstrap_proxy() {
    local vm_ip="$1"

    echo "  Starting bootstrap SOCKS proxy (SSH tunnel)..."

    # Check if host SSH is available
    if ! check_host_ssh; then
        echo "  âš  Cannot start bootstrap proxy (host SSH not available)"
        return 1
    fi

    # Start SSH SOCKS tunnel from VM to Host
    # -D 1080: SOCKS proxy on localhost:1080
    # -f: background
    # -N: no command
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "ssh -D 1080 -f -N -o StrictHostKeyChecking=yes -o ServerAliveInterval=60 ${HOST_USER}@${HOST_GATEWAY}" 2>> "$CAL_LOG"

    # Wait for tunnel to start
    sleep 2

    # Verify tunnel is running
    local tunnel_running
    tunnel_running=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "nc -z localhost 1080 && echo yes || echo no" 2>> "$CAL_LOG")

    if [ "$tunnel_running" = "yes" ]; then
        echo "  âœ“ Bootstrap SOCKS proxy started (localhost:1080)"
        return 0
    else
        echo "  âš  Bootstrap proxy may not have started"
        return 1
    fi
}

# Stop bootstrap SOCKS proxy
stop_bootstrap_proxy() {
    local vm_ip="$1"

    echo "  Stopping bootstrap SOCKS proxy..."

    # Find and kill the SSH tunnel process
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "pkill -f 'ssh -D 1080' 2>/dev/null || true" 2>> "$CAL_LOG"

    echo "  âœ“ Bootstrap proxy stopped"
}


# Run vm-setup script from ~/scripts folder
run_vm_setup() {
    local vm_ip="$1"
    local use_proxy="${2:-false}"

    echo "  Running ~/scripts/vm-setup.sh..."

    # Build environment variables
    local env_vars="HOST_USER='${HOST_USER}' PROXY_MODE='${PROXY_MODE}' HOST_GATEWAY='${HOST_GATEWAY}' CAL_VM_NAME='${VM_DEV}' VM_PASSWORD='${VM_PASSWORD}'"

    # If using proxy during init (bootstrap SOCKS), set proxy env vars
    # socks5h:// tells curl to resolve DNS through the proxy too
    if [ "$use_proxy" = "true" ]; then
        env_vars="${env_vars} ALL_PROXY='socks5h://localhost:1080' http_proxy='socks5h://localhost:1080' https_proxy='socks5h://localhost:1080'"
    fi

    if ! ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "${env_vars} ~/scripts/vm-setup.sh"; then
        echo ""
        echo "âœ— vm-setup.sh failed"
        echo ""
        echo "Check ~/.cal-bootstrap.log for details"
        return 1
    fi
}

# Setup scripts folder in VM with helper scripts
setup_scripts_folder() {
    local vm_ip="$1"

    echo "  Creating ~/scripts directory in VM..."
    if ! ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "mkdir -p ~/scripts" 2>> "$CAL_LOG"; then
        echo "    âœ— Failed to create ~/scripts directory"
        return 1
    fi

    # List of scripts to deploy
    local scripts=("vm-setup.sh" "vm-auth.sh" "vm-first-run.sh" "tmux-wrapper.sh" "vm-tmux-resurrect.sh")
    local scripts_to_copy=()
    local scripts_skipped=0

    # If --clean mode, always copy all scripts (skip checksum optimization)
    if [ "$CLEAN_MODE" = true ]; then
        echo "  Copying scripts to ~/scripts (--clean mode, skipping optimization)..."
        scripts_to_copy=("${scripts[@]}")
    else
        echo "  Checking scripts (comparing checksums)..."

        # Check each script and only copy if different or missing
        for script in "${scripts[@]}"; do
            local script_path="$SCRIPT_DIR/$script"

            # Skip if script doesn't exist on host
            if [ ! -f "$script_path" ]; then
                echo "    âš  $script not found on host"
                continue
            fi

            # Compute MD5 of host script
            local host_md5
            host_md5=$(md5 -q "$script_path" 2>> "$CAL_LOG")

            # Get MD5 of VM script (if it exists)
            local vm_md5
            vm_md5=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                "${VM_USER}@${vm_ip}" "[ -f ~/scripts/$script ] && md5 -q ~/scripts/$script || echo 'missing'" 2>> "$CAL_LOG")

            # Compare checksums
            if [ "$host_md5" = "$vm_md5" ]; then
                echo "    â†» $script (unchanged)"
                scripts_skipped=$((scripts_skipped + 1))
            else
                if [ "$vm_md5" = "missing" ]; then
                    echo "    + $script (new)"
                else
                    echo "    â†‘ $script (updated)"
                fi
                scripts_to_copy+=("$script")
            fi
        done
    fi

    # Copy scripts that need updating
    if [ ${#scripts_to_copy[@]} -gt 0 ]; then
        if [ "$CLEAN_MODE" != true ]; then
            echo "  Copying ${#scripts_to_copy[@]} script(s)..."
        fi

        for script in "${scripts_to_copy[@]}"; do
            local script_path="$SCRIPT_DIR/$script"

            if [ -f "$script_path" ]; then
                if scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                    "$script_path" "${VM_USER}@${vm_ip}":~/scripts/ 2>> "$CAL_LOG"; then
                    echo "    âœ“ $script"
                else
                    echo "    âœ— $script (copy failed)"
                fi
            fi
        done
    else
        echo "  All scripts up to date (skipped ${scripts_skipped})"
    fi

    # Make scripts executable
    if ! ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "chmod +x ~/scripts/*.sh" 2>> "$CAL_LOG"; then
        echo "    âš  Failed to make scripts executable"
    fi

    # Add ~/scripts to PATH in .zshrc if not already present
    echo "  Adding ~/scripts to PATH in .zshrc..."
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "if ! grep -q 'export PATH=\"\$HOME/scripts:\$PATH\"' ~/.zshrc; then echo 'export PATH=\"\$HOME/scripts:\$PATH\"' >> ~/.zshrc; echo '    âœ“ Added to PATH'; else echo '    âœ“ Already in PATH'; fi" 2>> "$CAL_LOG"

    echo "  âœ“ Scripts folder configured"
}

# Unlock keychain for SSH sessions (enables agent authentication)
# Returns 0 even on failure to avoid blocking SSH connection
unlock_keychain() {
    local vm_ip="$1"

    echo "  Unlocking keychain for SSH access..."
    if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${vm_ip}" "security unlock-keychain -p '${VM_PASSWORD}' login.keychain 2>/dev/null"; then
        echo "  âœ“ Keychain unlocked"
        return 0
    else
        echo "  âš  Could not unlock keychain (may already be unlocked)"
        return 0
    fi
}

# Setup Tart cache access from shared host cache (for nested VM support)
# Returns 0 even on failure to avoid blocking VM startup
setup_tart_cache_sharing() {
    local vm_ip="$1"

    echo "  Setting up Tart cache sharing..."

    # Check if shared directory is mounted
    local shared_cache_mounted
    shared_cache_mounted=$(ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "[ -d '/Volumes/My Shared Files/tart-cache' ] && echo yes || echo no" 2>/dev/null || echo "no")

    if [ "$shared_cache_mounted" != "yes" ]; then
        echo "  âš  Host Tart cache not shared (skipping)"
        return 0
    fi

    # Set up symlink from ~/.tart/cache to shared cache
    # This allows Tart inside the VM to use host's cached images
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "
        # Create .tart directory if it doesn't exist
        mkdir -p ~/.tart

        # Remove existing cache if it's a directory (not a symlink)
        if [ -d ~/.tart/cache ] && [ ! -L ~/.tart/cache ]; then
            echo '  Found existing cache directory, removing...'
            rm -rf ~/.tart/cache
        fi

        # Create symlink if it doesn't exist
        if [ ! -e ~/.tart/cache ]; then
            ln -s '/Volumes/My Shared Files/tart-cache' ~/.tart/cache
            echo '  âœ“ Symlink created: ~/.tart/cache -> /Volumes/My Shared Files/tart-cache'
        elif [ -L ~/.tart/cache ]; then
            echo '  âœ“ Symlink already exists'
        else
            echo '  âš  ~/.tart/cache exists but is not a symlink (manual intervention needed)'
        fi
    " 2>> "$CAL_LOG"

    echo "  âœ“ Tart cache sharing configured"
    return 0
}


# NOTE: SSH commands throughout this file use similar patterns
# TODO: Future refactoring opportunity - create ssh_to_vm() helper function
# to reduce duplication of: -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null
# However, this would trade off code clarity for DRYness - evaluate trade-offs

# Check VM for uncommitted or unpushed git changes
# Always returns 0 (success) unless critical failure
# Outputs warnings to stdout, sets global variables:
#   - has_uncommitted, has_unpushed (true/false)
#   - uncommitted_check, unpushed_check (repo paths with changes)
check_vm_git_changes() {
    local vm_name="$1"
    local vm_ip="$2"

    has_uncommitted=false
    has_unpushed=false
    uncommitted_check=""
    unpushed_check=""

    if [ -z "$vm_ip" ]; then
        echo "  âš  No VM IP provided for git check"
        return 0  # Non-fatal, allow script to continue
    fi

    echo "Checking for git changes in $vm_name..."

    # Check for uncommitted changes (search common dev directories + home with depth limit)
    uncommitted_check=$(ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" 'for gitdir in $(find ~/workspace ~/projects ~/repos ~/code 2>/dev/null -name ".git" -type d 2>/dev/null; find ~ -maxdepth 2 -name ".git" -type d 2>/dev/null | sort -u); do dir=$(dirname "$gitdir"); (cd "$dir" 2>/dev/null && [ -n "$(git status --porcelain 2>/dev/null)" ] && echo "$dir"); done' 2>/dev/null || echo "")

    if [ -n "$uncommitted_check" ]; then
        has_uncommitted=true
    fi

    # Check for unpushed commits (requires upstream tracking to be set)
    unpushed_check=$(ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" 'for gitdir in $(find ~/workspace ~/projects ~/repos ~/code 2>/dev/null -name ".git" -type d 2>/dev/null; find ~ -maxdepth 2 -name ".git" -type d 2>/dev/null | sort -u); do dir=$(dirname "$gitdir"); (cd "$dir" 2>/dev/null && branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null); if [ "$branch" != "HEAD" ] && git rev-parse "$branch@{u}" >/dev/null 2>&1 && [ -n "$(git log "@{u}.." --oneline 2>/dev/null)" ]; then echo "$dir"; fi); done' 2>/dev/null || echo "")

    if [ -n "$unpushed_check" ]; then
        has_unpushed=true
    fi

    # Show warnings
    if [ "$has_uncommitted" = true ] || [ "$has_unpushed" = true ]; then
        echo ""
        echo "âš ï¸  WARNING: Found git changes that will be lost!"
        echo ""

        if [ "$has_uncommitted" = true ]; then
            echo "Uncommitted changes in:"
            echo "$uncommitted_check" | while read -r repo; do
                [ -n "$repo" ] && echo "  - $repo"
            done
            echo ""
        fi

        if [ "$has_unpushed" = true ]; then
            echo "Unpushed commits in:"
            echo "$unpushed_check" | while read -r repo; do
                [ -n "$repo" ] && echo "  - $repo"
            done
            echo ""
        fi

        echo "These changes will be lost if you continue."
    else
        echo "  âœ“ No uncommitted or unpushed changes found"
    fi

    # Always return 0 for set -e compatibility
    return 0
}

# Test if VM can reach github.com (for auto mode)
test_vm_connectivity() {
    local vm_ip="$1"

    echo "  Testing VM network connectivity to github.com..."
    if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${vm_ip}" "curl -s --connect-timeout 5 -I https://github.com 2>&1 | grep -q 'HTTP'" 2>> "$CAL_LOG"; then
        echo "  âœ“ VM can reach github.com directly"
        return 0
    else
        echo "  âš  VM cannot reach github.com (needs transparent proxy)"
        return 1
    fi
}

# Check if host SSH server is available (required for transparent proxy)
check_host_ssh() {
    echo "  Checking if host SSH server is available..."

    # Check if SSH is listening on the host gateway IP
    if nc -z -w 2 "$HOST_GATEWAY" 22 2>/dev/null; then
        echo "  âœ“ Host SSH server is running"
        return 0
    else
        echo "  âš  Host SSH server not available on $HOST_GATEWAY:22"
        echo ""
        echo "  Transparent proxy requires SSH server on host Mac."
        echo "  To enable Remote Login (SSH):"
        echo "    System Settings â†’ General â†’ Sharing â†’ Remote Login (ON)"
        echo "  Or via command line:"
        echo "    sudo systemsetup -setremotelogin on"
        echo ""
        echo "  Skipping transparent proxy setup."
        echo "[$(date)] Host SSH not available on $HOST_GATEWAY:22" >> "$CAL_LOG"
        return 1
    fi
}

# Check if host has Python (required for sshuttle server side)
check_host_python() {
    echo "  Checking if host has Python (required for sshuttle)..."

    # Check for python3 first, then python
    if command -v python3 &>/dev/null; then
        local py_version
        py_version=$(python3 --version 2>&1)
        echo "  âœ“ Host has $py_version"
        return 0
    elif command -v python &>/dev/null; then
        local py_version
        py_version=$(python --version 2>&1)
        echo "  âœ“ Host has $py_version"
        return 0
    else
        echo "  âš  Python not found on host"
        echo "  sshuttle requires Python on the server side."
        echo "  macOS should have Python pre-installed. Check with:"
        echo "    python3 --version"
        echo "[$(date)] Python not found on host" >> "$CAL_LOG"
        return 1
    fi
}

# Setup SSH key in VM for transparent proxy back to host
# Note: sshuttle needs full SSH access (runs Python on server)
setup_vm_ssh_key() {
    local vm_ip="$1"

    echo "  Setting up VM SSH key for transparent proxy..."

    # Check if host SSH is available first
    if ! check_host_ssh; then
        return 1
    fi

    # Check if host has Python (required for sshuttle)
    if ! check_host_python; then
        return 1
    fi

    # Check if VM already has an SSH key
    local has_key
    has_key=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "[ -f ~/.ssh/id_ed25519 ] && echo yes || echo no" 2>> "$CAL_LOG")

    if [ "$has_key" = "yes" ]; then
        echo "  âœ“ VM SSH key already exists"
    else
        echo "  Generating SSH key in VM..."
        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "${VM_USER}@${vm_ip}" "ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519 -N '' -C 'cal-vm-proxy' >/dev/null 2>&1" 2>> "$CAL_LOG"
        echo "  âœ“ VM SSH key generated"
    fi

    # Get the VM's public key
    local vm_pubkey
    vm_pubkey=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "cat ~/.ssh/id_ed25519.pub" 2>> "$CAL_LOG")

    if [ -z "$vm_pubkey" ]; then
        echo "  âš  Could not retrieve VM public key"
        echo "[$(date)] Failed to retrieve VM public key from $vm_ip" >> "$CAL_LOG"
        return 1
    fi

    # Get the key fingerprint for comparison (more reliable than comment)
    local vm_key_fp
    vm_key_fp=$(echo "$vm_pubkey" | ssh-keygen -lf - 2>/dev/null | awk '{print $2}')

    if [ -z "$vm_key_fp" ]; then
        echo "  âš  Could not calculate key fingerprint"
        echo "[$(date)] Failed to calculate fingerprint for VM key" >> "$CAL_LOG"
        return 1
    fi

    # Check if this specific key is already in host's authorized_keys (by fingerprint)
    mkdir -p ~/.ssh
    chmod 700 ~/.ssh
    touch ~/.ssh/authorized_keys
    chmod 600 ~/.ssh/authorized_keys

    local key_exists=false
    if [ -s ~/.ssh/authorized_keys ]; then
        # Check each key's fingerprint (suppress any debug output)
        while IFS= read -r line; do
            [ -z "$line" ] && continue
            [[ "$line" =~ ^# ]] && continue
            local existing_fp=""
            existing_fp=$(echo "$line" | awk '{print $1, $2}' | ssh-keygen -lf - 2>/dev/null | awk '{print $2}') 2>/dev/null
            if [ "$existing_fp" = "$vm_key_fp" ]; then
                key_exists=true
                break
            fi
        done < ~/.ssh/authorized_keys 2>/dev/null
    fi

    if [ "$key_exists" = "true" ]; then
        echo "  âœ“ VM key already in host authorized_keys (fingerprint: ${vm_key_fp:0:16}...)"
    else
        echo "  Adding VM key to host authorized_keys..."
        # sshuttle needs full SSH access (runs Python on server side)
        # The key is only accessible from the VM's local network
        echo "$vm_pubkey" >> ~/.ssh/authorized_keys
        echo "  âœ“ VM key added to host"
        echo "[$(date)] Added VM key with fingerprint $vm_key_fp" >> "$CAL_LOG"
    fi

    # Pre-populate host's SSH key in VM's known_hosts for secure connections
    echo "  Setting up host key verification in VM..."
    setup_vm_known_hosts "$vm_ip"

    # Test SSH from VM to host
    echo "  Testing VMâ†’Host SSH connection..."
    if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${vm_ip}" "ssh -o StrictHostKeyChecking=yes -o ConnectTimeout=5 ${HOST_USER}@${HOST_GATEWAY} 'echo ok'" 2>> "$CAL_LOG"; then
        echo "  âœ“ VM can SSH to host (with host key verification)"
        return 0
    else
        echo "  âš  VMâ†’Host SSH test failed (tunnel may still work)"
        echo "[$(date)] VMâ†’Host SSH test failed" >> "$CAL_LOG"
        return 0
    fi
}

# Pre-populate VM's known_hosts with host's SSH key
# This enables StrictHostKeyChecking=yes for security
setup_vm_known_hosts() {
    local vm_ip="$1"

    # Get host's SSH public keys
    local host_keys
    host_keys=$(ssh-keyscan -H "$HOST_GATEWAY" 2>/dev/null)

    if [ -z "$host_keys" ]; then
        echo "  âš  Could not scan host SSH keys"
        echo "[$(date)] ssh-keyscan failed for $HOST_GATEWAY" >> "$CAL_LOG"
        return 1
    fi

    # Add host keys to VM's known_hosts
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "mkdir -p ~/.ssh && chmod 700 ~/.ssh && cat >> ~/.ssh/known_hosts" <<< "$host_keys" 2>> "$CAL_LOG"

    echo "  âœ“ Host SSH keys added to VM's known_hosts"
}

# Start transparent proxy (sshuttle) in VM
# This provides truly transparent network routing - no app configuration needed
start_transparent_proxy() {
    local vm_ip="$1"

    echo "  Checking transparent proxy (sshuttle)..."

    # Check if sshuttle is already running
    local proxy_running
    proxy_running=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "pgrep -f sshuttle >/dev/null && echo yes || echo no" 2>> "$CAL_LOG")

    if [ "$proxy_running" = "yes" ]; then
        echo "  âœ“ Transparent proxy already running"
        show_proxy_cow "$vm_ip"
        return 0
    fi

    # Check if sshuttle is installed (source Homebrew for PATH)
    local has_sshuttle
    has_sshuttle=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "eval \"\$(/opt/homebrew/bin/brew shellenv)\" 2>/dev/null; command -v sshuttle >/dev/null && echo yes || echo no" 2>> "$CAL_LOG")

    if [ "$has_sshuttle" != "yes" ]; then
        echo "  âš  sshuttle not installed in VM"
        echo "  Run vm-setup.sh to install sshuttle"
        echo "[$(date)] sshuttle not found in VM" >> "$CAL_LOG"
        return 1
    fi

    echo "  Starting transparent proxy (sshuttle)..."

    # Start sshuttle in background (source Homebrew for PATH)
    # Routes all traffic (0.0.0.0/0) through host, handles DNS
    # Excludes local/VM network to prevent routing loops
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "eval \"\$(/opt/homebrew/bin/brew shellenv)\" 2>/dev/null; nohup sshuttle --dns -r ${HOST_USER}@${HOST_GATEWAY} 0.0.0.0/0 -x ${HOST_GATEWAY}/32 -x 192.168.64.0/24 >> ~/.cal-proxy.log 2>&1 &" 2>> "$CAL_LOG"

    # Wait for sshuttle to start
    local count=0
    local max_wait=10
    while [ $count -lt $max_wait ]; do
        sleep 1
        count=$((count + 1))
        proxy_running=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "${VM_USER}@${vm_ip}" "pgrep -f sshuttle >/dev/null && echo yes || echo no" 2>> "$CAL_LOG")
        if [ "$proxy_running" = "yes" ]; then
            echo "  âœ“ Transparent proxy started"
            show_proxy_cow "$vm_ip"
            return 0
        fi
    done

    echo "  âš  Transparent proxy may not have started (check ~/.cal-proxy.log in VM)"
    echo "[$(date)] sshuttle start timeout after ${max_wait}s" >> "$CAL_LOG"
    return 1
}

# Show the celebratory cow when proxy is working
show_proxy_cow() {
    local vm_ip="$1"

    # Test that proxy actually works
    local test_result
    test_result=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "curl -s --connect-timeout 5 -I https://www.google.com 2>&1 | grep -q '200' && echo yes || echo no" 2>> "$CAL_LOG")

    if [ "$test_result" = "yes" ]; then
        echo ""
        echo " ___________________________"
        echo "< Transparent proxy works! >"
        echo " ---------------------------"
        echo "        \\   ^__^"
        echo "         \\  (oo)\\_______"
        echo "            (__)\\       )\\/\\"
        echo "                ||----w |"
        echo "                ||     ||"
        echo ""
    else
        echo "[$(date)] Proxy connectivity test failed" >> "$CAL_LOG"
    fi
}

# Determine whether to enable proxy based on mode
should_enable_proxy() {
    local vm_ip="$1"

    case "$PROXY_MODE" in
        on)
            echo "  Proxy mode: on (forced)"
            return 0
            ;;
        off)
            echo "  Proxy mode: off (disabled)"
            return 1
            ;;
        auto)
            echo "  Proxy mode: auto (testing connectivity...)"
            if test_vm_connectivity "$vm_ip"; then
                echo "  â†’ Network OK, transparent proxy not needed"
                return 1
            else
                echo "  â†’ Network restricted, enabling transparent proxy"
                return 0
            fi
            ;;
        *)
            echo "  âš  Invalid PROXY_MODE='$PROXY_MODE', defaulting to auto"
            PROXY_MODE="auto"
            should_enable_proxy "$vm_ip"
            ;;
    esac
}

# === INIT MODE ===
do_init() {
    echo ""
    echo "CAL Bootstrap - Initialize"
    echo "==========================="
    echo ""

    # Setup cache directories on host (for package download caching)
    echo "Setting up cache directories..."
    if [ ! -d ~/.cal-cache ]; then
        mkdir -p ~/.cal-cache/{homebrew,npm,go,git}
        echo "  âœ“ Created cache directories: homebrew, npm, go, git"
    else
        echo "  âœ“ Cache directory already exists"
        # Ensure all subdirectories exist
        mkdir -p ~/.cal-cache/{homebrew,npm,go,git}
    fi
    echo ""

    # Check upfront if we'll be deleting existing VMs
    local dev_exists=false
    local init_exists=false

    if vm_exists "$VM_DEV"; then
        dev_exists=true
    fi

    if vm_exists "$VM_INIT"; then
        init_exists=true
    fi

    # Offer to replace cal-init with current cal-dev before proceeding
    if [ "$init_exists" = true ] && [ "$dev_exists" = true ]; then
        if [ "$SKIP_CONFIRM" = false ]; then
            echo "Do you want to replace $VM_INIT with current $VM_DEV? (y/N)"
            read -r -k 1 reply
            echo ""
            if [[ $reply =~ ^[Yy]$ ]]; then
                echo ""
                echo "Replacing $VM_INIT with current $VM_DEV..."

                # Start cal-dev if not running (need IP to set first-run flag)
                local dev_was_running=false
                if vm_running "$VM_DEV"; then
                    dev_was_running=true
                    DEV_IP=$("$TART" ip "$VM_DEV" 2>/dev/null || echo "")
                else
                    echo "  Starting $VM_DEV to set first-run flag..."
                    if start_vm_background "$VM_DEV"; then
                        DEV_IP="$VM_IP"
                    else
                        echo "  âš  Failed to start $VM_DEV"
                        echo "  â†’ Cannot set first-run flag, manually run ~/scripts/vm-first-run.sh after restoring $VM_INIT"
                        exit 1
                    fi
                fi

                # Set first-run flag in cal-dev (will be copied to cal-init)
                echo "  Setting first-run flag in $VM_DEV..."
                if ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                       "${VM_USER}@${DEV_IP}" "touch ~/.cal-first-run && sync && [ -f ~/.cal-first-run ] && echo 'success'" 2>> "$CAL_LOG" | grep -q 'success'; then
                    echo "  âœ“ First-run flag set"
                else
                    echo "  âš  Failed to set first-run flag"
                    echo "  â†’ Manually run ~/scripts/vm-first-run.sh after restoring $VM_INIT"
                fi

                # Stop cal-dev
                stop_vm "$VM_DEV"
                CLEANUP_VM=false

                # Delete cal-init
                echo "  Deleting $VM_INIT..."
                "$TART" delete "$VM_INIT"

                # Clone cal-dev to cal-init (first-run flag gets copied)
                echo "  Creating $VM_INIT from $VM_DEV..."
                "$TART" clone "$VM_DEV" "$VM_INIT"
                echo "  âœ“ First-run flag copied to $VM_INIT"

                # If cal-dev was running before, restart it and remove the flag
                if [ "$dev_was_running" = true ]; then
                    echo "  Restarting $VM_DEV..."
                    if start_vm_background "$VM_DEV"; then
                        CLEANUP_VM=false
                        echo "  Removing first-run flag from $VM_DEV..."
                        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                            "${VM_USER}@${VM_IP}" "rm -f ~/.cal-first-run && sync" 2>> "$CAL_LOG"
                        echo "  âœ“ $VM_DEV restarted and ready"
                    else
                        echo "  âš  Failed to restart $VM_DEV"
                    fi
                fi

                echo ""
                echo "  âœ“ $VM_INIT replaced with current $VM_DEV"
                echo ""
                exit 0
            else
                echo "Aborted. Existing VMs not modified."
                exit 0
            fi
        fi
    fi

    # If either exists, warn and check git before proceeding
    if [ "$dev_exists" = true ] || [ "$init_exists" = true ]; then
        echo "âš ï¸  WARNING: Existing VMs will be deleted!"
        echo ""

        if [ "$dev_exists" = true ] && [ "$init_exists" = true ]; then
            echo "Initializing will DELETE both $VM_DEV and $VM_INIT."
        elif [ "$dev_exists" = true ]; then
            echo "Initializing will DELETE $VM_DEV."
        else
            echo "Initializing will DELETE $VM_INIT."
        fi

        echo "All data and changes will be permanently lost."
        echo ""

        # Check for git changes in cal-dev if it exists
        if [ "$dev_exists" = true ]; then
            local we_started_vm=false
            local vm_ip=""

            # Start VM if not running to check for changes
            if ! vm_running "$VM_DEV"; then
                echo "Starting $VM_DEV to check for uncommitted changes..."
                if start_vm_background "$VM_DEV"; then
                    we_started_vm=true
                    vm_ip="$VM_IP"
                else
                    echo "  âš  Could not start VM to check for git changes"
                    echo "  Proceeding without git check..."
                fi
            else
                vm_ip=$("$TART" ip "$VM_DEV" 2>/dev/null || echo "")
            fi

            # Check for git changes if VM is running
            if [ -n "$vm_ip" ]; then
                check_vm_git_changes "$VM_DEV" "$vm_ip"
            fi

            # Stop VM if we started it just for the git check
            if [ "$we_started_vm" = true ]; then
                echo ""
                echo "Stopping $VM_DEV..."
                stop_vm "$VM_DEV"
                CLEANUP_VM=false
            fi
        fi

        # Get confirmation for the entire operation
        if [ "$SKIP_CONFIRM" = false ]; then
            echo ""
            if [ "$dev_exists" = true ] && [ "$init_exists" = true ]; then
                echo "Delete $VM_DEV and $VM_INIT, then re-initialize? (y/N)"
            elif [ "$dev_exists" = true ]; then
                echo "Delete $VM_DEV and re-initialize? (y/N)"
            else
                echo "Delete $VM_INIT and re-initialize? (y/N)"
            fi
            read -r -k 1 reply
            echo ""
            if [[ ! $reply =~ ^[Yy]$ ]]; then
                echo "Aborted initialization"
                exit 1
            fi
        fi

        # Delete existing VMs
        if [ "$dev_exists" = true ]; then
            stop_vm "$VM_DEV"
            echo "  Deleting $VM_DEV..."
            "$TART" delete "$VM_DEV"
        fi

        if [ "$init_exists" = true ]; then
            stop_vm "$VM_INIT"
            echo "  Deleting $VM_INIT..."
            "$TART" delete "$VM_INIT"
        fi

        echo ""
    fi

    # Step 1: Create cal-clean from base image
    echo "Step 1: Create $VM_CLEAN"
    if vm_exists "$VM_CLEAN"; then
        echo "  $VM_CLEAN already exists, skipping"
    else
        echo "  Cloning from ghcr.io/cirruslabs/macos-sequoia-base:latest..."
        echo "  (This downloads ~25GB, may take a while)"
        "$TART" clone ghcr.io/cirruslabs/macos-sequoia-base:latest "$VM_CLEAN"
        echo "  Setting VM resources (4 CPU, 8GB RAM, 80GB disk)..."
        "$TART" set "$VM_CLEAN" --cpu 4 --memory 8192 --disk-size 80
        echo "  $VM_CLEAN created"
    fi

    # Step 2: Create cal-dev from cal-clean
    echo ""
    echo "Step 2: Create $VM_DEV"
    echo "  Cloning from $VM_CLEAN..."
    "$TART" clone "$VM_CLEAN" "$VM_DEV"
    echo "  $VM_DEV created"
    
    # Enable cleanup of cal-dev if init fails (incomplete/unstable VM)
    CLEANUP_DELETE_CALDEV=true
    
    # Step 3: Start cal-dev and setup
    echo ""
    echo "Step 3: Setup $VM_DEV"
    if ! start_vm_background "$VM_DEV"; then
        echo "  Failed to start VM"
        exit 1
    fi
    
    # Step 4: Setup SSH keys (hostâ†’VM)
    echo ""
    echo "Step 4: Setup SSH keys (hostâ†’VM)"
    setup_ssh_keys "$VM_IP"

    # Step 5: Setup proxy for network access
    echo ""
    echo "Step 5: Setup network access"
    local proxy_enabled=false
    local bootstrap_proxy_started=false

    if should_enable_proxy "$VM_IP"; then
        echo "  Proxy mode enabled, setting up VMâ†’Host SSH..."
        if setup_vm_ssh_key "$VM_IP"; then
            proxy_enabled=true
            echo "  âœ“ VMâ†’Host SSH ready"

            # Start bootstrap SOCKS proxy for package installation
            # (sshuttle isn't installed yet, so use SSH -D tunnel)
            echo ""
            echo "Step 5.5: Start bootstrap proxy for package installation"
            if start_bootstrap_proxy "$VM_IP"; then
                bootstrap_proxy_started=true
            else
                echo "  âš  Bootstrap proxy failed, will try direct connection"
            fi
        else
            echo "  âš  VMâ†’Host SSH setup failed, will try direct connection"
        fi
    else
        echo "  âœ“ Direct network connection available"
    fi

    # Step 6: Setup scripts folder first
    echo ""
    echo "Step 6: Setup scripts folder"
    setup_scripts_folder "$VM_IP"

    # Step 6.5: Set first-run flag BEFORE vm-setup creates tmux config
    # This prevents tmux-resurrect from capturing the vm-auth screen during initial setup
    echo ""
    echo "Step 6.5: Set first-run flag"
    echo "  Setting first-run flag in $VM_DEV..."
    if ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${VM_IP}" "touch ~/.cal-first-run && sync && [ -f ~/.cal-first-run ] && echo 'success'" 2>> "$CAL_LOG" | grep -q 'success'; then
        echo "  âœ“ First-run flag set (TPM will not load until after first login)"
    else
        echo "  âš  Failed to set first-run flag"
        echo "  â†’ vm-auth screen may be captured by tmux-resurrect"
    fi

    # Step 7: Run vm-setup from ~/scripts
    # Pass proxy flag so vm-setup knows to use SOCKS proxy env vars
    echo ""
    echo "Step 7: Install tools"
    if ! run_vm_setup "$VM_IP" "$bootstrap_proxy_started"; then
        echo ""
        echo "âš ï¸  Initialization failed - cleaning up..."
        cleanup
        exit 1
    fi

    # Allow time for filesystem sync before reboot
    sleep 2

    # Step 7.5: Clean up bootstrap proxy and start sshuttle
    if [ "$bootstrap_proxy_started" = "true" ]; then
        echo ""
        echo "Step 7.5: Switch to transparent proxy (sshuttle)"
        stop_bootstrap_proxy "$VM_IP"
        start_transparent_proxy "$VM_IP" || echo "  âš  sshuttle start failed (see logs)"
    elif [ "$proxy_enabled" = "true" ]; then
        # Proxy was requested but bootstrap failed - try sshuttle anyway
        echo ""
        echo "Step 7.5: Start transparent proxy (sshuttle)"
        start_transparent_proxy "$VM_IP" || echo "  âš  sshuttle start failed (see logs)"
    fi

    # Step 8: Reboot VM to apply .zshrc configuration
    echo ""
    echo "Step 8: Reboot VM to apply configuration"
    echo "  Stopping VM..."
    "$TART" stop "$VM_DEV" 2>/dev/null || true
    kill "$TART_PID" 2>/dev/null || true
    sleep 2
    
    echo "  Restarting VM..."
    if ! start_vm_background "$VM_DEV"; then
        echo "  Failed to restart VM"
        exit 1
    fi

    # Restart proxy after reboot if it was enabled
    if [ "$proxy_enabled" = "true" ] || [ "$bootstrap_proxy_started" = "true" ]; then
        echo "  Restarting transparent proxy..."
        start_transparent_proxy "$VM_IP" || echo "  âš  Proxy restart failed"
    fi

    # Step 9: Open login shell for agent authentication
    # The .zshrc auth-needed check will automatically run vm-auth.sh
    echo ""
    echo "============================================"
    echo "Agent Authentication"
    echo "============================================"
    echo ""
    echo "Opening login shell in VM (vm-auth.sh will run automatically)..."
    echo ""

    # SSH into VM with login shell - .zshrc will:
    # 1. Unlock keychain
    # 2. Detect auth-needed flag and run vm-auth.sh
    # 3. Clear auth-needed flag
    # Use tmux-wrapper.sh to set TERM properly for compatibility with exotic terminals
    ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${VM_IP}" "~/scripts/tmux-wrapper.sh new-session -A -s setup 'zsh -l'"

    echo ""
    echo "Continuing with setup..."

    # Sync filesystem after vm-auth (ensure repository clones are persisted)
    echo "  Syncing filesystem to disk..."
    ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${VM_IP}" "sync && sleep 2" 2>> "$CAL_LOG"
    echo "  âœ“ Filesystem synced"

    # Step 9.5: Verify first-run flag exists (set in Step 6.5, persisted through reboot)
    echo ""
    echo "Step 9.5: Prepare $VM_INIT snapshot"
    echo "  Verifying first-run flag in $VM_DEV (will be copied to $VM_INIT)..."
    if ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${VM_IP}" "[ -f ~/.cal-first-run ] && echo 'exists'" 2>> "$CAL_LOG" | grep -q 'exists'; then
        echo "  âœ“ First-run flag exists in $VM_DEV (will be copied to $VM_INIT)"
    else
        echo "  âš  First-run flag missing! Setting it now..."
        ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "${VM_USER}@${VM_IP}" "touch ~/.cal-first-run && sync" 2>> "$CAL_LOG"
        echo "  â†’ vm-first-run.sh will execute after restoring $VM_INIT"
    fi

    # Step 10: Create cal-init snapshot
    echo ""
    echo "Step 10: Create $VM_INIT snapshot"

    # Clear tmux session data before snapshot (prevents auth screen capture)
    echo "  Clearing tmux session data..."
    ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${VM_IP}" "rm -rf ~/.local/share/tmux/resurrect/* 2>/dev/null || true" 2>> "$CAL_LOG"
    echo "  âœ“ Tmux sessions cleared"

    # Stop VM first
    CLEANUP_VM=false
    echo "  Stopping $VM_DEV..."
    "$TART" stop "$VM_DEV" 2>/dev/null || true
    kill "$TART_PID" 2>/dev/null || true
    sleep 2

    # Create cal-init (already deleted upfront if it existed)
    # The first-run flag is already set in cal-dev, so it gets copied to cal-init
    echo "  Creating $VM_INIT from $VM_DEV..."
    "$TART" clone "$VM_DEV" "$VM_INIT"
    echo "  $VM_INIT created"
    echo "  âœ“ First-run flag copied to $VM_INIT (will run vm-first-run.sh when restored)"
    
    # Bootstrap succeeded - disable cal-dev cleanup
    CLEANUP_DELETE_CALDEV=false
    
    echo ""
    echo "Bootstrap complete!"
    echo ""
    echo "VMs created:"
    printf "  %-17s - Base macOS image\n" "$VM_CLEAN"
    printf "  %-17s - Development VM (use this)\n" "$VM_DEV"
    printf "  %-17s - Snapshot with tools configured\n" "$VM_INIT"
    echo ""
    echo "Starting $VM_DEV for development..."
    echo ""

    # Auto-start cal-dev
    if ! start_vm_background "$VM_DEV"; then
        echo "Failed to start VM"
        echo "Run './cal-bootstrap --run' to start manually"
        exit 1
    fi

    # Don't cleanup on success
    CLEANUP_VM=false

    echo ""
    echo "$VM_DEV is running (PID: $TART_PID)"

    # Setup and start transparent proxy if needed
    if should_enable_proxy "$VM_IP"; then
        # Ensure VM SSH key is set up (idempotent - safe to run multiple times)
        if setup_vm_ssh_key "$VM_IP"; then
            start_transparent_proxy "$VM_IP" || echo "  âš  Transparent proxy failed to start (see ~/.cal-bootstrap.log)"
        else
            echo "  âš  Skipping transparent proxy (setup failed)"
        fi
    fi

    # Unlock keychain for SSH access
    unlock_keychain "$VM_IP"

    # Ensure scripts folder is set up (idempotent - safe to run multiple times)
    setup_scripts_folder "$VM_IP"

    # Setup Tart cache sharing for nested VM support
    setup_tart_cache_sharing "$VM_IP"

    # Step 10.5: Remove first-run flag from cal-dev
    # cal-dev is the working VM and needs TPM/session persistence enabled
    # cal-init (cloned above) keeps the flag for first login after restore
    echo ""
    echo "Step 10.5: Prepare $VM_DEV for use"
    echo "  Removing first-run flag from $VM_DEV..."
    if ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${VM_IP}" "rm -f ~/.cal-first-run && sync && [ ! -f ~/.cal-first-run ] && echo 'success'" 2>> "$CAL_LOG" | grep -q 'success'; then
        echo "  âœ“ First-run flag removed (TPM will load normally, session persistence enabled)"
    else
        echo "  âš  Failed to remove first-run flag - vm-first-run.sh may run on connect"
    fi

    echo ""
    echo "VNC:   open vnc://${VM_IP}"
    echo "Stop:  $TART stop $VM_DEV"
    echo ""
    echo "Connecting via SSH with tmux..."
    echo "ðŸ’¡ tmux session 'cal-dev' (Ctrl+b d to detach, Ctrl+b ? for help)"
    echo ""

    # SSH into the VM with tmux (always)
    # Use tmux-wrapper.sh to set TERM properly for compatibility with exotic terminals
    # Check for first-run flag - if it exists, DON'T use auto-restore (let vm-first-run.sh run first)
    # Only use -A flag (auto-restore) if flag doesn't exist
    if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${VM_IP}" "[ -f ~/.cal-first-run ]" 2>> "$CAL_LOG"; then
        # First run - don't auto-restore (vm-first-run.sh needs to run first)
        ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "${VM_USER}@${VM_IP}" "~/scripts/tmux-wrapper.sh new-session -s cal-dev"
    else
        # Normal run - use auto-restore
        ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "${VM_USER}@${VM_IP}" "~/scripts/tmux-wrapper.sh new-session -A -s cal-dev"
    fi
}

# === RUN MODE ===
do_run() {
    echo ""
    echo "CAL Bootstrap - Run"
    echo "===================="
    echo ""
    
    local vm_to_run="$VM_DEV"
    
    # Check if VM exists
    if ! vm_exists "$vm_to_run"; then
        echo "$vm_to_run does not exist."
        echo ""
        echo "Run './cal-bootstrap --init' to set up the environment."
        exit 1
    fi
    
    # If already running, just SSH in
    if vm_running "$vm_to_run"; then
        echo "$vm_to_run is already running."
        VM_IP=$("$TART" ip "$vm_to_run" 2>/dev/null || echo "")
        if [ -n "$VM_IP" ]; then
            echo ""
            # Setup and start transparent proxy if needed
            if should_enable_proxy "$VM_IP"; then
                # Ensure VM SSH key is set up (idempotent - safe to run multiple times)
                if setup_vm_ssh_key "$VM_IP"; then
                    start_transparent_proxy "$VM_IP" || echo "  âš  Transparent proxy failed to start (see ~/.cal-bootstrap.log)"
                else
                    echo "  âš  Skipping transparent proxy (setup failed)"
                fi
            fi
            unlock_keychain "$VM_IP"
            # Ensure scripts folder is set up (idempotent - safe to run multiple times)
            setup_scripts_folder "$VM_IP"
            # Setup Tart cache sharing for nested VM support
            setup_tart_cache_sharing "$VM_IP"
            echo ""
            echo "Connecting via SSH with tmux..."
            echo "ðŸ’¡ tmux session 'cal-dev' (Ctrl+b d to detach, Ctrl+b ? for help)"
            echo ""
            # Use tmux-wrapper.sh to set TERM properly for compatibility with exotic terminals
            ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                "${VM_USER}@${VM_IP}" "~/scripts/tmux-wrapper.sh new-session -A -s cal-dev"
        else
            echo "Could not get VM IP address."
            exit 1
        fi
        exit 0
    fi
    
    # Start VM
    if ! start_vm_background "$vm_to_run"; then
        echo "Failed to start VM"
        exit 1
    fi
    
    # Don't cleanup on success
    CLEANUP_VM=false

    echo ""
    echo "$vm_to_run is running (PID: $TART_PID)"

    # Setup and start transparent proxy if needed
    if should_enable_proxy "$VM_IP"; then
        # Ensure VM SSH key is set up (idempotent - safe to run multiple times)
        if setup_vm_ssh_key "$VM_IP"; then
            start_transparent_proxy "$VM_IP" || echo "  âš  Transparent proxy failed to start (see ~/.cal-bootstrap.log)"
        else
            echo "  âš  Skipping transparent proxy (setup failed)"
        fi
    fi

    # Unlock keychain for SSH access
    unlock_keychain "$VM_IP"

    # Ensure scripts folder is set up (idempotent - safe to run multiple times)
    setup_scripts_folder "$VM_IP"

    # Setup Tart cache sharing for nested VM support
    setup_tart_cache_sharing "$VM_IP"

    echo ""
    echo "VNC:   open vnc://${VM_IP}"
    echo "Stop:  $TART stop $vm_to_run"
    echo ""
    echo "ðŸ’¡ If agent login fails, use Screen Sharing (standard mode, not High Performance):"
    echo "   open vnc://${VM_IP} â†’ Authenticate agent â†’ Return to terminal"
    echo ""
    echo "Connecting via SSH with tmux..."
    echo "ðŸ’¡ tmux session 'cal-dev' (Ctrl+b d to detach, Ctrl+b ? for help)"
    echo ""

    # SSH into the VM with tmux (always)
    # Use tmux-wrapper.sh to set TERM properly for compatibility with exotic terminals
    # Check for first-run flag - if it exists, DON'T use auto-restore (let vm-first-run.sh run first)
    # Only use -A flag (auto-restore) if flag doesn't exist
    if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${VM_IP}" "[ -f ~/.cal-first-run ]" 2>> "$CAL_LOG"; then
        # First run - don't auto-restore (vm-first-run.sh needs to run first)
        ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "${VM_USER}@${VM_IP}" "~/scripts/tmux-wrapper.sh new-session -s cal-dev"
    else
        # Normal run - use auto-restore
        ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "${VM_USER}@${VM_IP}" "~/scripts/tmux-wrapper.sh new-session -A -s cal-dev"
    fi
}

# === STOP MODE ===
do_stop() {
    echo ""
    echo "CAL Bootstrap - Stop"
    echo "===================="
    echo ""

    if ! vm_exists "$VM_DEV"; then
        echo "$VM_DEV does not exist."
        exit 1
    fi

    if ! vm_running "$VM_DEV"; then
        echo "$VM_DEV is not running."
        exit 0
    fi

    # Save tmux sessions before stopping
    save_tmux_sessions "$VM_DEV"
    echo ""

    echo "Stopping $VM_DEV..."
    "$TART" stop "$VM_DEV"
    echo ""
    echo "$VM_DEV stopped."
}

# === RESTART MODE ===
do_restart() {
    echo ""
    echo "CAL Bootstrap - Restart"
    echo "========================="
    echo ""

    if ! vm_exists "$VM_DEV"; then
        echo "$VM_DEV does not exist."
        echo ""
        echo "Run './cal-bootstrap --init' to set up the environment."
        exit 1
    fi

    # Stop if running
    if vm_running "$VM_DEV"; then
        # Save tmux sessions before stopping
        save_tmux_sessions "$VM_DEV"
        echo ""

        echo "Stopping $VM_DEV..."
        "$TART" stop "$VM_DEV"
        sleep 2
        echo ""
    fi

    # Start VM
    if ! start_vm_background "$VM_DEV"; then
        echo "Failed to start VM"
        exit 1
    fi

    # Don't cleanup on success
    CLEANUP_VM=false

    echo ""
    echo "$VM_DEV is running (PID: $TART_PID)"

    # Setup and start transparent proxy if needed
    if should_enable_proxy "$VM_IP"; then
        # Ensure VM SSH key is set up (idempotent - safe to run multiple times)
        if setup_vm_ssh_key "$VM_IP"; then
            start_transparent_proxy "$VM_IP" || echo "  âš  Transparent proxy failed to start (see ~/.cal-bootstrap.log)"
        else
            echo "  âš  Skipping transparent proxy (setup failed)"
        fi
    fi

    # Unlock keychain for SSH access
    unlock_keychain "$VM_IP"

    # Ensure scripts folder is set up (idempotent - safe to run multiple times)
    setup_scripts_folder "$VM_IP"

    # Setup Tart cache sharing for nested VM support
    setup_tart_cache_sharing "$VM_IP"

    echo ""
    echo "VNC:   open vnc://${VM_IP}"
    echo "Stop:  $TART stop $VM_DEV"
    echo ""
    echo "ðŸ’¡ If agent login fails, use Screen Sharing (standard mode, not High Performance):"
    echo "   open vnc://${VM_IP} â†’ Authenticate agent â†’ Return to terminal"
    echo ""
    echo "Connecting via SSH with tmux..."
    echo "ðŸ’¡ tmux session 'cal-dev' (Ctrl+b d to detach, Ctrl+b ? for help)"
    echo ""

    # SSH into the VM with tmux (always)
    # Use tmux-wrapper.sh to set TERM properly for compatibility with exotic terminals
    # Check for first-run flag - if it exists, DON'T use auto-restore (let vm-first-run.sh run first)
    # Only use -A flag (auto-restore) if flag doesn't exist
    if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${VM_IP}" "[ -f ~/.cal-first-run ]" 2>> "$CAL_LOG"; then
        # First run - don't auto-restore (vm-first-run.sh needs to run first)
        ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "${VM_USER}@${VM_IP}" "~/scripts/tmux-wrapper.sh new-session -s cal-dev"
    else
        # Normal run - use auto-restore
        ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "${VM_USER}@${VM_IP}" "~/scripts/tmux-wrapper.sh new-session -A -s cal-dev"
    fi
}

# === GUI MODE ===
do_gui() {
    echo ""
    echo "CAL Bootstrap - GUI"
    echo "===================="
    echo ""

    # Check if VM exists
    if ! vm_exists "$VM_DEV"; then
        echo "$VM_DEV does not exist."
        echo ""
        echo "Run './cal-bootstrap --init' to set up the environment."
        exit 1
    fi

    # Stop if already running (need to restart with VNC flags)
    if vm_running "$VM_DEV"; then
        echo "$VM_DEV is already running. Stopping to restart with VNC..."
        "$TART" stop "$VM_DEV"
        sleep 2
        echo ""
    fi

    echo "Starting $VM_DEV with VNC (experimental mode for clipboard support)..."
    echo ""
    echo "ðŸ’¡ VNC Features:"
    echo "   - Full GUI access to macOS desktop"
    echo "   - Bidirectional clipboard (copy/paste works both ways)"
    echo "   - No disconnect issues with paste operations"
    echo ""
    echo "â„¹ï¸  Why experimental mode?"
    echo "   Standard VNC (--vnc) has clipboard issues: Hostâ†’VM paste causes disconnect"
    echo "   Experimental mode (--vnc-experimental) uses Virtualization.Framework VNC"
    echo "   This solves clipboard problems but may have occasional display quirks"
    echo ""

    # Run with VNC experimental mode (background process)
    # This allows the terminal to remain free while VNC window is open
    #
    # Why --vnc-experimental instead of --vnc:
    # - Standard --vnc mode uses macOS Screen Sharing with known clipboard issues
    #   (Hostâ†’VM paste causes Screen Sharing disconnect)
    # - Experimental mode uses Virtualization.Framework's built-in VNC server
    # - Provides reliable bidirectional clipboard support
    # - Trade-off: May have experimental bugs (display, input) but clipboard works
    # - Tested and confirmed working for clipboard operations (2026-01-31)

    # Build tart run command with cache sharing
    local tart_cmd=("$TART" "run" "$VM_DEV" "--vnc-experimental")

    # Share host's Tart cache with VM (read-only) to avoid duplicate downloads
    if [ -d ~/.tart/cache ]; then
        tart_cmd+=("--dir" "tart-cache:${HOME}/.tart/cache:ro,tag=com.apple.virtio-fs.automount")
    fi

    # Share host's package cache with VM (read-write) for Homebrew, npm, Go, Git caches
    if [ -d ~/.cal-cache ]; then
        tart_cmd+=("--dir" "cal-cache:${HOME}/.cal-cache:rw,tag=com.apple.virtio-fs.automount")
    fi

    "${tart_cmd[@]}" >/dev/null 2>&1 &
    TART_PID=$!

    # Wait for VM to get an IP address
    echo "  Waiting for VM to start..."
    local max_wait=30
    local count=0
    VM_IP=""

    while [ $count -lt $max_wait ]; do
        sleep 2
        count=$((count + 2))
        VM_IP=$("$TART" ip "$VM_DEV" 2>/dev/null || echo "")
        if [ -n "$VM_IP" ]; then
            break
        fi
    done

    echo ""
    echo "VNC window should open automatically."
    echo "VM running in background (PID: $TART_PID)"

    if [ -n "$VM_IP" ]; then
        echo "VM IP: $VM_IP"
        echo ""
        echo "To stop the VM:"
        echo "  ./cal-bootstrap --stop"
        echo ""
        echo "To reconnect to VNC if window closes:"
        echo "  ./cal-bootstrap --gui"
    else
        echo ""
        echo "To stop the VM:"
        echo "  ./cal-bootstrap --stop"
    fi
    echo ""
}

# === STATUS MODE ===
do_status() {
    echo "CAL Environment Status"
    echo "======================"
    echo ""

    # Check if jq is available for JSON parsing
    if ! command -v jq &>/dev/null; then
        echo "âš  jq not installed (install with: brew install jq)"
        echo "  Using fallback status display"
        echo ""

        # Fallback to simple text output
        echo "VMs:"
        "$TART" list 2>/dev/null | while IFS= read -r line; do
            echo "  $line"
        done
        echo ""

        # Check cal-dev specifically
        if vm_exists "$VM_DEV"; then
            if vm_running "$VM_DEV"; then
                echo "$VM_DEV: Running"
                local dev_ip
                dev_ip=$("$TART" ip "$VM_DEV" 2>/dev/null || echo "")
                if [ -n "$dev_ip" ]; then
                    echo "  IP: $dev_ip"
                else
                    echo "  IP: (not available)"
                fi
            else
                echo "$VM_DEV: Stopped"
            fi
        else
            echo "$VM_DEV: Not found"
            echo ""
            echo "Run './cal-bootstrap --init' to set up the environment."
        fi
        return 0
    fi

    # Get VM data using JSON for accurate information
    local json_output
    json_output=$("$TART" list --format json 2>&1)

    if [ $? -ne 0 ] || [ -z "$json_output" ]; then
        echo "Error: Failed to get VM list from tart"
        exit 1
    fi

    # Check if cal-dev exists
    local dev_exists
    dev_exists=$(echo "$json_output" | jq -r ".[] | select(.Name == \"$VM_DEV\") | .Name" 2>/dev/null)

    if [ -z "$dev_exists" ]; then
        echo "Status: Not initialized"
        echo ""
        echo "Run './cal-bootstrap --init' to set up the environment."
        exit 0
    fi

    # Get cal-dev info
    local dev_state dev_size dev_ip
    dev_state=$(echo "$json_output" | jq -r ".[] | select(.Name == \"$VM_DEV\") | .State" 2>/dev/null)
    dev_size=$(echo "$json_output" | jq -r ".[] | select(.Name == \"$VM_DEV\") | .Size" 2>/dev/null)

    # Size is already in GB from the JSON
    local size_display
    if [ -n "$dev_size" ] && [ "$dev_size" != "null" ]; then
        size_display="${dev_size} GB"
    else
        size_display="unknown"
    fi

    echo "VM: $VM_DEV"
    echo "State: $dev_state"
    echo "Size: ${size_display}"

    if [ "$dev_state" = "running" ]; then
        dev_ip=$("$TART" ip "$VM_DEV" 2>/dev/null || echo "")
        if [ -n "$dev_ip" ]; then
            echo "IP: $dev_ip"
            echo ""
            echo "Access:"
            echo "  SSH:  ssh ${VM_USER}@${dev_ip}"
            echo "  VNC:  open vnc://${dev_ip}"
            echo ""
            echo "Commands:"
            echo "  Connect: ./cal-bootstrap --run"
            echo "  GUI:     ./cal-bootstrap --gui"
            echo "  Stop:    ./cal-bootstrap --stop"
        else
            echo "IP: (not available yet)"
            echo ""
            echo "VM is booting..."
        fi
    else
        echo ""
        echo "Commands:"
        echo "  Start:   ./cal-bootstrap --run"
        echo "  GUI:     ./cal-bootstrap --gui"
    fi

    echo ""

    # Show other VMs if they exist
    local clean_exists init_exists
    clean_exists=$(echo "$json_output" | jq -r ".[] | select(.Name == \"$VM_CLEAN\") | .Name" 2>/dev/null)
    init_exists=$(echo "$json_output" | jq -r ".[] | select(.Name == \"$VM_INIT\") | .Name" 2>/dev/null)

    if [ -n "$clean_exists" ] || [ -n "$init_exists" ]; then
        echo "System VMs:"
        if [ -n "$clean_exists" ]; then
            echo "  âœ“ $VM_CLEAN (base image)"
        fi
        if [ -n "$init_exists" ]; then
            echo "  âœ“ $VM_INIT (snapshot for restore)"
        fi
        echo ""
    fi

    # Show snapshot count
    local snapshot_count
    snapshot_count=$(echo "$json_output" | jq -r '[.[] | select(.Name != "'$VM_CLEAN'" and .Name != "'$VM_DEV'" and .Name != "'$VM_INIT'")] | length' 2>/dev/null)

    if [ -n "$snapshot_count" ] && [ "$snapshot_count" -gt 0 ]; then
        echo "Snapshots: $snapshot_count"
        echo "  List: ./cal-bootstrap --snapshot list"
        echo ""
    fi
}

# === SNAPSHOT MODE ===
do_snapshot() {
    local action="$1"
    local name="$2"
    
    echo ""
    echo "CAL Bootstrap - Snapshot"
    echo "========================="
    echo ""
    
    case "$action" in
        create)
            if [ -z "$name" ]; then
                echo "Usage: ./cal-bootstrap --snapshot create <name>"
                exit 1
            fi
            
            # Stop VM if running
            stop_vm "$VM_DEV"

            local snapshot_name="$name"

            if vm_exists "$snapshot_name"; then
                if [ "$SKIP_CONFIRM" = true ]; then
                    "$TART" delete "$snapshot_name"
                else
                    echo "Snapshot $snapshot_name already exists. Replace? (y/N)"
                    read -r -k 1 reply
                    echo ""
                    if [[ $reply =~ ^[Yy]$ ]]; then
                        "$TART" delete "$snapshot_name"
                    else
                        echo "Aborted"
                        exit 1
                    fi
                fi
            fi
            
            echo "Creating snapshot: $snapshot_name"
            "$TART" clone "$VM_DEV" "$snapshot_name"
            echo ""
            echo "Snapshot created: $snapshot_name"
            echo ""
            echo "Restore with: ./cal-bootstrap --snapshot restore $name"
            ;;
            
        restore)
            if [ -z "$name" ]; then
                echo "Usage: ./cal-bootstrap --snapshot restore <name>"
                echo ""
                do_snapshot list
                exit 1
            fi

            # Resolve short name to full name
            local restore_from
            restore_from=$(resolve_vm_name "$name")

            if [ -z "$restore_from" ]; then
                echo "VM '$name' not found"
                echo ""
                do_snapshot list
                exit 1
            fi

            # Can't restore from cal-dev to cal-dev
            if [ "$restore_from" = "$VM_DEV" ]; then
                echo "Cannot restore $VM_DEV from itself"
                exit 1
            fi

            # Handle two scenarios:
            # 1. cal-dev exists: Check for git changes, confirm, delete, then clone from snapshot
            # 2. cal-dev doesn't exist: Skip git checks, just confirm and create from snapshot
            # Check if cal-dev exists
            if vm_exists "$VM_DEV"; then
                # cal-dev exists - check for git changes before replacing
                local we_started_vm=false
                local vm_ip=""

                # Start VM if not running
                if ! vm_running "$VM_DEV"; then
                    echo "Starting $VM_DEV to check for uncommitted changes..."
                    if start_vm_background "$VM_DEV"; then
                        we_started_vm=true
                        vm_ip="$VM_IP"
                    else
                        echo "  âš  Could not start VM to check for git changes"
                        echo "  Proceeding without git check..."
                    fi
                else
                    vm_ip=$("$TART" ip "$VM_DEV" 2>/dev/null || echo "")
                fi

                # Check for git changes if VM is running
                if [ -n "$vm_ip" ]; then
                    check_vm_git_changes "$VM_DEV" "$vm_ip"
                fi

                # Stop VM if we started it just for the git check
                if [ "$we_started_vm" = true ]; then
                    echo ""
                    echo "Stopping $VM_DEV..."
                    stop_vm "$VM_DEV"
                    CLEANUP_VM=false
                fi

                # Confirmation prompt (after showing git warnings if any)
                if [ "$SKIP_CONFIRM" = false ]; then
                    echo ""
                    echo "This will replace $VM_DEV with $restore_from"
                    echo "All changes in $VM_DEV will be lost!"
                    echo ""
                    echo "Continue? (y/N)"
                    read -r -k 1 reply
                    echo ""
                    if [[ ! $reply =~ ^[Yy]$ ]]; then
                        echo "Aborted"
                        exit 1
                    fi
                fi

                # Stop and delete current VM
                stop_vm "$VM_DEV"

                echo "Deleting $VM_DEV..."
                if ! "$TART" delete "$VM_DEV"; then
                    echo ""
                    echo "âš ï¸  Failed to delete $VM_DEV"
                    echo ""
                    echo "This can happen if:"
                    echo "  â€¢ VM is in an inconsistent state"
                    echo "  â€¢ Tart is holding a lock on the VM"
                    echo "  â€¢ Another process is using the VM"
                    echo ""
                    echo "You may need to delete it manually:"
                    echo "  tart delete $VM_DEV"
                    echo ""
                    echo "Or restart your machine if Tart is locked."
                    echo ""
                    echo "Aborting restore."
                    exit 1
                fi
            else
                # cal-dev doesn't exist - create it from snapshot
                echo "$VM_DEV does not exist."
                echo "Creating $VM_DEV from $restore_from..."
                echo ""

                # Confirmation prompt
                if [ "$SKIP_CONFIRM" = false ]; then
                    echo "Create $VM_DEV from $restore_from? (y/N)"
                    read -r -k 1 reply
                    echo ""
                    if [[ ! $reply =~ ^[Yy]$ ]]; then
                        echo "Aborted"
                        exit 1
                    fi
                fi
            fi

            # Restore from snapshot
            echo "Restoring from $restore_from..."
            "$TART" clone "$restore_from" "$VM_DEV"
            
            echo ""
            echo "Restored $VM_DEV from $restore_from"
            echo ""
            
            # Give different instructions based on what was restored
            if [ "$restore_from" = "$VM_CLEAN" ]; then
                echo "âš ï¸  Restored from clean base image (no tools installed)"
                echo ""
                echo "Run './cal-bootstrap --init' to set up tools and agents"
            else
                echo "Run './cal-bootstrap --run' to start the VM"
            fi
            ;;
            
        list)
            # Check if jq is available (required for JSON parsing)
            if ! command -v jq &>/dev/null; then
                echo "Error: jq is required for listing VMs with size information"
                echo ""
                echo "Install with: brew install jq"
                echo ""
                exit 1
            fi

            # Check for short name collisions (use text output for this)
            local collision_check
            collision_check=$("$TART" list 2>/dev/null | awk 'NR==1 {next} {
                full_name = $2
                source = $1

                # Create short name
                short_name = full_name
                if (source == "OCI") {
                    gsub(/ghcr.io\/cirruslabs\/macos-/, "", short_name)
                    if (match(short_name, /@sha256:/)) {
                        short_name = substr(short_name, 1, RSTART-1) "-digest"
                    }
                }

                print short_name
            }' | sort | uniq -d)

            if [ -n "$collision_check" ]; then
                echo "âš ï¸  WARNING: Short name collisions detected!"
                echo "   Use full names for these VMs:"
                echo ""
            fi

            # List VMs using JSON for accurate size data
            local json_output
            json_output=$("$TART" list --format json 2>&1)

            if [ $? -ne 0 ] || [ -z "$json_output" ]; then
                echo "Error: Failed to get VM list from tart"
                echo ""
                echo "Try running: tart list"
                echo ""
                exit 1
            fi

            local parsed_data
            parsed_data=$(echo "$json_output" | jq -r '.[] | "\(.Name)|\(.Source)|\(.Size)|\(.State)"' 2>&1)

            if [ $? -ne 0 ]; then
                echo "Error: Failed to parse VM data"
                echo ""
                echo "This may indicate a problem with tart or jq."
                echo "Try running: tart list --format json"
                echo ""
                exit 1
            fi

            echo "$parsed_data" | awk -F'|' -v collisions="$collision_check" '
                BEGIN {
                    # Build collision map
                    split(collisions, coll_array, "\n")
                    for (i in coll_array) {
                        collision_map[coll_array[i]] = 1
                    }
                    total_size = 0
                }
                {
                    full_name = $1
                    source = $2
                    size = $3
                    state = $4

                    # Add to total
                    total_size += size

                    # Create short name for display
                    short_name = full_name
                    if (source == "OCI") {
                        gsub(/ghcr.io\/cirruslabs\/macos-/, "", short_name)
                        if (match(short_name, /@sha256:/)) {
                            short_name = substr(short_name, 1, RSTART-1) "-digest"
                        }
                    }

                    # Determine which name to show
                    display_name = (short_name in collision_map) ? full_name : short_name

                    # Format size with GB suffix and space
                    size_str = size " GB"

                    # If name is too long, put it on its own line
                    if (length(display_name) > 40) {
                        printf "  %s\n", display_name
                        printf "  %-40s %-10s (%s)\n", "", size_str, state
                    } else {
                        printf "  %-40s %-10s (%s)\n", display_name, size_str, state
                    }
                }
                END {
                    print ""
                    printf "Total: %d GB\n", total_size
                }'

            echo ""
            exit 0
            ;;
            
        delete)
            # Support both old single-name syntax and new multiple-name syntax
            local vms_to_delete=()

            # Check if using array (new syntax) or single name (backwards compatibility)
            if [ ${#SNAPSHOT_NAMES[@]} -gt 0 ]; then
                vms_to_delete=("${SNAPSHOT_NAMES[@]}")
            elif [ -n "$name" ]; then
                vms_to_delete=("$name")
            else
                echo "Usage: ./cal-bootstrap --snapshot delete [--force] <name> [<name2> ...]"
                echo ""
                echo "Options:"
                echo "  --force  Skip git checks and avoid booting VMs"
                echo ""
                do_snapshot list
                exit 1
            fi

            # Show force mode status
            if [ "$FORCE_DELETE" = "true" ]; then
                echo "Force mode: Skipping git checks and VM booting"
                echo ""
            fi

            # Declare loop variables once (function-scoped in shell)
            local vm_to_delete
            local we_started_vm
            local vm_ip

            # Process each VM
            for vm_name in "${vms_to_delete[@]}"; do
                echo "Processing: $vm_name"
                echo ""

                # Resolve short name to full name
                vm_to_delete=$(resolve_vm_name "$vm_name")

                if [ -z "$vm_to_delete" ]; then
                    echo "âš ï¸  VM '$vm_name' not found, skipping"
                    echo ""
                    continue
                fi

                # Check for git changes before deleting (unless --force or cal-clean)
                if [ "$FORCE_DELETE" = "false" ] && [ "$vm_to_delete" != "$VM_CLEAN" ]; then
                    we_started_vm=false
                    vm_ip=""

                    # Start VM if not running to check for changes
                    if ! vm_running "$vm_to_delete"; then
                        echo "Starting $vm_to_delete to check for uncommitted changes..."
                        if start_vm_background "$vm_to_delete"; then
                            we_started_vm=true
                            vm_ip="$VM_IP"
                        else
                            echo "  âš  Could not start VM to check for git changes"
                            echo "  Proceeding without git check..."
                        fi
                    else
                        vm_ip=$("$TART" ip "$vm_to_delete" 2>/dev/null || echo "")
                    fi

                    # Check for git changes if VM is running
                    if [ -n "$vm_ip" ]; then
                        check_vm_git_changes "$vm_to_delete" "$vm_ip"
                        echo ""
                    fi

                    # Stop VM if we started it just for the git check
                    if [ "$we_started_vm" = true ]; then
                        echo "Stopping $vm_to_delete..."
                        stop_vm "$vm_to_delete"
                        CLEANUP_VM=false
                        echo ""
                    fi
                fi

                # Stop the VM before deletion (if still running)
                stop_vm "$vm_to_delete"

                # Confirm (with extra warning for system VMs)
                if [ "$SKIP_CONFIRM" = false ]; then
                    if [ "$vm_to_delete" = "$VM_DEV" ]; then
                        echo "âš ï¸  WARNING: Deleting your working VM!"
                        echo ""
                        echo "This will delete $vm_to_delete permanently."
                        echo "You may want to use restore instead to reset state."
                        echo ""
                    elif [ "$vm_to_delete" = "$VM_CLEAN" ]; then
                        echo "âš ï¸  WARNING: Deleting the clean base image!"
                        echo ""
                        echo "This will delete $vm_to_delete permanently."
                        echo "You'll need to re-download (~25GB) to recreate it."
                        echo ""
                    elif [ "$vm_to_delete" = "$VM_INIT" ]; then
                        echo "âš ï¸  WARNING: Deleting the initialized snapshot!"
                        echo ""
                        echo "This will delete $vm_to_delete permanently."
                        echo "You'll need to run --init again to recreate it."
                        echo ""
                    fi
                    echo "Delete $vm_to_delete?"
                    echo ""
                    echo "Continue? (y/N)"
                    read -r -k 1 reply
                    echo ""
                    if [[ ! $reply =~ ^[Yy]$ ]]; then
                        echo "Skipped: $vm_to_delete"
                        echo ""
                        continue
                    fi
                fi

                echo "Deleting $vm_to_delete..."
                if "$TART" delete "$vm_to_delete"; then
                    echo "âœ“ Deleted: $vm_to_delete"
                else
                    echo "âœ— Failed to delete: $vm_to_delete"
                fi
                echo ""
            done

            echo "Delete operation complete"
            ;;
            
        *)
            echo "Usage: ./cal-bootstrap --snapshot <list|create|restore|delete> [options] [name...]"
            echo ""
            echo "Examples:"
            echo "  ./cal-bootstrap --snapshot list"
            echo "  ./cal-bootstrap --snapshot create before-refactor"
            echo "  ./cal-bootstrap --snapshot restore before-refactor"
            echo "  ./cal-bootstrap --snapshot delete before-refactor"
            echo "  ./cal-bootstrap --snapshot delete snap1 snap2 snap3"
            echo "  ./cal-bootstrap --snapshot delete --force unresponsive-vm"
            exit 1
            ;;
    esac
}

# === MAIN ===

# Parse arguments
MODE=""
SKIP_CONFIRM=false
CLEAN_MODE=false
SNAPSHOT_ACTION=""
SNAPSHOT_NAME=""
SNAPSHOT_NAMES=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        --init|-i)
            MODE="init"
            shift
            ;;
        --run)
            MODE="run"
            shift
            ;;
        --restart|-r)
            MODE="restart"
            shift
            ;;
        --gui|-g)
            MODE="gui"
            shift
            ;;
        --stop)
            MODE="stop"
            shift
            ;;
        --status|-s)
            MODE="status"
            shift
            ;;
        --snapshot|-S)
            MODE="snapshot"
            shift
            SNAPSHOT_ACTION="${1:-}"
            [[ $# -gt 0 ]] && shift

            # For delete action, collect all VM names (after checking for --force and --yes)
            if [ "$SNAPSHOT_ACTION" = "delete" ]; then
                # Collect all remaining arguments, handling flags and VM names
                SNAPSHOT_NAMES=()
                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --force)
                            FORCE_DELETE=true
                            shift
                            ;;
                        --yes|-y)
                            SKIP_CONFIRM=true
                            shift
                            ;;
                        --*)
                            # Unknown flag for delete action - stop processing
                            break
                            ;;
                        *)
                            # VM name
                            SNAPSHOT_NAMES+=("$1")
                            shift
                            ;;
                    esac
                done
            else
                # For other actions (create, restore), just take one name
                SNAPSHOT_NAME="${1:-}"
                [[ $# -gt 0 ]] && shift
            fi
            ;;
        --socks|--proxy)
            shift
            PROXY_MODE="${1:-auto}"
            if [[ ! "$PROXY_MODE" =~ ^(on|off|auto)$ ]]; then
                echo "Error: --proxy must be 'on', 'off', or 'auto'"
                echo "Got: '$PROXY_MODE'"
                exit 1
            fi
            shift
            ;;
        --yes|-y)
            SKIP_CONFIRM=true
            shift
            ;;
        --clean)
            CLEAN_MODE=true
            shift
            ;;
        --help|-h)
            echo "CAL Bootstrap - VM Environment Setup"
            echo ""
            echo "Usage: ./cal-bootstrap [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --init, -i                          Initialize VM environment"
            echo "  --run                               Run cal-dev with tmux (default if VMs exist)"
            echo "  --restart, -r                       Restart cal-dev and connect with tmux"
            echo "  --gui, -g                           Launch cal-dev with VNC GUI (experimental mode)"
            echo "                                        Provides full macOS desktop with clipboard support"
            echo "  --stop                              Stop cal-dev"
            echo "  --status, -s                        Show VM status and connection info"
            echo "  --snapshot, -S list                 List available snapshots"
            echo "  --snapshot, -S create <name>        Create a named snapshot"
            echo "  --snapshot, -S restore <name>       Restore from a snapshot"
            echo "  --snapshot, -S delete [--force] <name> [<name2> ...]"
            echo "                                      Delete one or more snapshots"
            echo "                                      --force: Skip git checks, avoid booting VMs"
            echo "  --proxy <on|off|auto>               Transparent proxy mode (default: auto)"
            echo "                                        on   - Always enable transparent proxy"
            echo "                                        off  - Disable transparent proxy"
            echo "                                        auto - Test github.com, enable if needed"
            echo "  --yes, -y                           Skip confirmation prompts"
            echo "  --clean                             Force script deployment (skip checksum optimization)"
            echo "  --help, -h                          Show this help"
            echo ""
            echo "Examples:"
            echo "  ./cal-bootstrap --init              # First-time setup"
            echo "  ./cal-bootstrap                     # Start cal-dev (auto-detects mode)"
            echo "  ./cal-bootstrap --status            # Show VM status and IP"
            echo "  ./cal-bootstrap --restart           # Restart cal-dev and connect"
            echo "  ./cal-bootstrap --gui               # Launch GUI with clipboard support"
            echo "  ./cal-bootstrap --snapshot create pre-experiment"
            echo "  ./cal-bootstrap --snapshot restore pre-experiment"
            echo "  ./cal-bootstrap --snapshot delete pre-experiment"
            echo "  ./cal-bootstrap --snapshot delete old-snap1 old-snap2 old-snap3"
            echo "  ./cal-bootstrap --snapshot delete --force unresponsive-vm"
            echo ""
            echo "Note: tmux is always used for persistent sessions."
            echo "      Ctrl+b d to detach, Ctrl+b ? for help"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Run './cal-bootstrap --help' for usage"
            exit 1
            ;;
    esac
done

# Find tart
TART=$(find_tart)
if [ -z "$TART" ]; then
    echo "Tart not found. Attempting to install..."
    echo ""

    # Check if brew is available
    if command -v brew &>/dev/null; then
        echo "Installing Tart via Homebrew..."
        if brew install cirruslabs/cli/tart; then
            echo "  âœ“ Tart installed successfully"
            echo ""

            # Find tart again after installation
            TART=$(find_tart)
            if [ -z "$TART" ]; then
                echo "Error: Tart was installed but still not found in PATH"
                echo "Try: source ~/.zshrc or restart your terminal"
                exit 1
            fi
        else
            echo "  âœ— Failed to install Tart via Homebrew"
            echo ""
            echo "Please install manually with: brew install cirruslabs/cli/tart"
            echo "Or set TART_PATH environment variable"
            exit 1
        fi
    else
        echo "Error: Homebrew not found"
        echo ""
        echo "Install Homebrew first: https://brew.sh"
        echo "Then install Tart with: brew install cirruslabs/cli/tart"
        echo ""
        echo "Or set TART_PATH environment variable"
        exit 1
    fi
fi

# Auto-detect mode if not specified
if [ -z "$MODE" ]; then
    if vm_exists "$VM_CLEAN" && vm_exists "$VM_DEV" && vm_exists "$VM_INIT"; then
        MODE="run"
    else
        MODE="init"
    fi
    echo "Auto-detected mode: $MODE"
fi

# Execute mode
case "$MODE" in
    init)
        do_init
        ;;
    run)
        do_run
        ;;
    restart)
        do_restart
        ;;
    gui)
        do_gui
        ;;
    stop)
        do_stop
        ;;
    status)
        do_status
        ;;
    snapshot)
        do_snapshot "$SNAPSHOT_ACTION" "$SNAPSHOT_NAME"
        ;;
esac
