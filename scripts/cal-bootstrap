#!/bin/zsh

set -e

# Get script directory (works in zsh)
SCRIPT_DIR="${0:A:h}"

# CAL Bootstrap Script
# Usage: ./cal-bootstrap [--init|-i] [--run] [--restart|-r] [--stop] [--snapshot <action> <name>]
#
# Options:
#   --init, -i      Initialize VM environment (create cal-clean, cal-dev, cal-init)
#   --run           Run cal-dev and SSH in with tmux (default if VMs exist)
#   --restart, -r   Restart cal-dev and SSH in with tmux
#   --stop, -s      Stop cal-dev
#   --snapshot, -S  Manage snapshots (list, create, restore, delete)
#   --yes, -y       Skip confirmation prompts
#
# Environment variables:
#   TART_PATH     - Path to tart binary
#   VM_USER       - VM username (default: admin)
#   VM_PASSWORD   - VM password (default: admin)

# VM names
VM_CLEAN="cal-clean"
VM_DEV="cal-dev"
VM_INIT="cal-init"

# VM credentials
VM_USER="${VM_USER:-admin}"
VM_PASSWORD="${VM_PASSWORD:-admin}"

# Host user for SOCKS tunnel (the user running this script)
HOST_USER="${HOST_USER:-$(whoami)}"

# SOCKS tunnel settings (configurable via environment)
SOCKS_MODE="${SOCKS_MODE:-auto}"  # on, off, or auto (default)
SOCKS_PORT="${SOCKS_PORT:-1080}"
HTTP_PROXY_PORT="${HTTP_PROXY_PORT:-8080}"  # HTTP-to-SOCKS bridge for Node.js tools
HOST_GATEWAY="${HOST_GATEWAY:-192.168.64.1}"

# Log file for debugging
CAL_LOG="${HOME}/.cal-bootstrap.log"

# Cleanup tracking
CLEANUP_VM=false
CLEANUP_DONE=false
TART_PID=""

# Cleanup function
cleanup() {
    if [ "$CLEANUP_DONE" = true ]; then
        return
    fi
    CLEANUP_DONE=true
    
    if [ "$CLEANUP_VM" = true ] && [ -n "$TART_PID" ] && kill -0 "$TART_PID" 2>/dev/null; then
        echo ""
        echo "Cleaning up background VM process (PID: $TART_PID)..."
        kill "$TART_PID" 2>/dev/null || true
        wait "$TART_PID" 2>/dev/null || true
    fi
}

# Handle Ctrl-C properly
handle_interrupt() {
    echo ""
    echo "Interrupted by user"
    cleanup
    exit 130
}

trap cleanup EXIT
trap handle_interrupt INT TERM

# Find tart binary
find_tart() {
    if command -v tart &>/dev/null; then
        echo "tart"
    elif [ -n "$TART_PATH" ] && [ -x "$TART_PATH" ]; then
        echo "$TART_PATH"
    elif [ -x "./tart.app/Contents/MacOS/tart" ]; then
        echo "./tart.app/Contents/MacOS/tart"
    else
        echo ""
    fi
}

# Check if VM exists
vm_exists() {
    "$TART" list 2>/dev/null | awk -v vm="$1" 'NR>1 { if ($2 == vm) { found=1; exit } } END { if (found) exit 0; else exit 1 }'
}

# Resolve VM name (short name to full name if needed)
resolve_vm_name() {
    local input_name="$1"
    
    # If VM exists with exact name, use it
    if vm_exists "$input_name"; then
        echo "$input_name"
        return 0
    fi
    
    # Try to find by short name pattern
    local matches
    matches=$("$TART" list 2>/dev/null | awk -v short="$input_name" '
        NR==1 {next}
        {
            full_name = $2
            source = $1
            
            # Create short name
            short_name = full_name
            if (source == "OCI") {
                gsub(/ghcr.io\/cirruslabs\/macos-/, "", short_name)
                if (match(short_name, /@sha256:/)) {
                    short_name = substr(short_name, 1, RSTART-1) "-digest"
                }
            }
            
            # Match short name
            if (short_name == short) {
                print full_name
            }
        }
    ')
    
    # Check for multiple matches (collision)
    local match_count
    match_count=$(echo "$matches" | grep -c '^' 2>/dev/null || echo 0)
    
    if [ "$match_count" -gt 1 ]; then
        echo "Error: Short name '$input_name' matches multiple VMs:" >&2
        echo "$matches" | sed 's/^/  - /' >&2
        echo "" >&2
        echo "Use full name instead." >&2
        return 2
    elif [ "$match_count" -eq 1 ]; then
        echo "$matches"
        return 0
    fi
    
    # Not found
    return 1
}

# Check if VM is running
vm_running() {
    "$TART" list 2>/dev/null | awk -v vm="$1" 'NR>1 { if ($2 == vm && $NF == "running") { found=1; exit } } END { if (found) exit 0; else exit 1 }'
}

# Stop VM if running
stop_vm() {
    local vm="$1"
    if vm_running "$vm"; then
        echo "  Stopping $vm..."
        "$TART" stop "$vm" 2>/dev/null || true
        sleep 2
    fi
}

# Start VM in background and wait for IP/SSH
start_vm_background() {
    local vm="$1"
    
    echo "  Starting $vm in background..."
    "$TART" run --no-graphics "$vm" >/dev/null 2>&1 &
    TART_PID=$!
    disown "$TART_PID" 2>/dev/null || true
    CLEANUP_VM=true
    echo "  VM started (PID: $TART_PID)"
    
    # Wait for IP
    echo "  Waiting for IP..."
    local max_wait=60
    local count=0
    VM_IP=""
    
    while [ $count -lt $max_wait ]; do
        sleep 2
        count=$((count + 2))
        VM_IP=$("$TART" ip "$vm" 2>/dev/null || echo "")
        if [ -n "$VM_IP" ]; then
            echo "  VM IP: $VM_IP"
            break
        fi
        printf "  Waiting... (%ds/%ds)\r" "$count" "$max_wait"
    done
    
    if [ -z "$VM_IP" ]; then
        echo "  Could not obtain IP after ${max_wait}s"
        return 1
    fi
    
    # Wait for SSH
    echo "  Waiting for SSH..."
    
    # Ensure sshpass is available for automated setup (install quietly if needed)
    if ! command -v sshpass &>/dev/null; then
        # Try to install sshpass silently
        brew install esolitos/ipa/sshpass &>/dev/null 2>&1 || \
        brew install hudochenkov/sshpass/sshpass &>/dev/null 2>&1 || true
    fi
    
    local has_sshpass=false
    local has_expect=false
    if command -v sshpass &>/dev/null; then
        has_sshpass=true
    elif command -v expect &>/dev/null; then
        has_expect=true
    fi
    
    count=0
    
    while [ $count -lt $max_wait ]; do
        if [ "$has_sshpass" = true ]; then
            # With sshpass: try automated password auth
            if SSHPASS="${VM_PASSWORD}" sshpass -e ssh -o ConnectTimeout=2 -o StrictHostKeyChecking=no \
                   -o UserKnownHostsFile=/dev/null -o PreferredAuthentications=password \
                   "${VM_USER}@${VM_IP}" "echo ok" &>/dev/null 2>&1; then
                echo "  SSH is ready"
                return 0
            fi
        elif [ "$has_expect" = true ]; then
            # With expect: try automated password auth
            if expect -c "
                set timeout 5
                spawn ssh -o ConnectTimeout=2 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${VM_USER}@${VM_IP} echo ok
                expect {
                    \"*assword*\" { send \"${VM_PASSWORD}\r\"; exp_continue }
                    \"ok\" { exit 0 }
                    timeout { exit 1 }
                    eof { exit 1 }
                }
            " &>/dev/null 2>&1; then
                echo "  SSH is ready"
                return 0
            fi
        else
            # Without sshpass or expect: check if SSH port is open
            if nc -z -w 2 "$VM_IP" 22 &>/dev/null; then
                echo "  SSH is ready"
                return 0
            fi
        fi
        sleep 2
        count=$((count + 2))
        printf "  Waiting for SSH... (%ds/%ds)\r" "$count" "$max_wait"
    done
    
    echo "  SSH not available after ${max_wait}s"
    return 1
}

# Setup SSH keys
setup_ssh_keys() {
    local vm_ip="$1"
    
    echo "  Checking SSH keys..."
    
    # Check if SSH key exists
    if [ ! -f ~/.ssh/id_rsa.pub ] && [ ! -f ~/.ssh/id_ed25519.pub ]; then
        echo "  No SSH key found. Generating..."
        ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519 -N "" -q
        echo "  SSH key generated"
    fi
    
    # Test if key auth already works
    if ssh -o BatchMode=yes -o ConnectTimeout=2 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${vm_ip}" "echo ok" &>/dev/null; then
        echo "  SSH key authentication already configured"
        return 0
    fi
    
    # Copy SSH key using sshpass for automation (silently)
    echo "  Copying SSH key to VM..."
    
    # Ensure sshpass or expect is available
    if ! command -v sshpass &>/dev/null; then
        brew install esolitos/ipa/sshpass &>/dev/null 2>&1 || \
        brew install hudochenkov/sshpass/sshpass &>/dev/null 2>&1 || true
    fi
    
    # Get public key
    local pubkey
    if [ -f ~/.ssh/id_ed25519.pub ]; then
        pubkey=$(cat ~/.ssh/id_ed25519.pub)
    else
        pubkey=$(cat ~/.ssh/id_rsa.pub)
    fi
    
    if command -v sshpass &>/dev/null; then
        # Use sshpass for automated key copy
        SSHPASS="${VM_PASSWORD}" sshpass -e ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "${VM_USER}@${vm_ip}" \
            "mkdir -p ~/.ssh && echo '$pubkey' >> ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys" &>/dev/null
    elif command -v expect &>/dev/null; then
        # Use expect as fallback (usually pre-installed on macOS)
        expect -c "
            set timeout 30
            spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${VM_USER}@${vm_ip} {mkdir -p ~/.ssh && echo '$pubkey' >> ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys}
            expect {
                \"*assword*\" { send \"${VM_PASSWORD}\r\"; exp_continue }
                eof
            }
        " &>/dev/null
    else
        # Last resort: manual password entry
        echo "  ‚ö†Ô∏è  Automated setup unavailable - password: ${VM_PASSWORD}"
        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "${VM_USER}@${vm_ip}" \
            "mkdir -p ~/.ssh && echo '$pubkey' >> ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys"
    fi
    
    echo "  SSH key copied"
}

# Run vm-setup script from ~/scripts folder
run_vm_setup() {
    local vm_ip="$1"

    echo "  Running ~/scripts/vm-setup.sh..."
    # Pass HOST_USER, SOCKS_MODE, SOCKS_PORT, HTTP_PROXY_PORT, and HOST_GATEWAY so vm-setup.sh can configure the tunnel
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "HOST_USER='${HOST_USER}' SOCKS_MODE='${SOCKS_MODE}' SOCKS_PORT='${SOCKS_PORT}' HTTP_PROXY_PORT='${HTTP_PROXY_PORT}' HOST_GATEWAY='${HOST_GATEWAY}' ~/scripts/vm-setup.sh"
}

# Setup scripts folder in VM with helper scripts
setup_scripts_folder() {
    local vm_ip="$1"

    echo "  Creating ~/scripts directory in VM..."
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "mkdir -p ~/scripts" 2>> "$CAL_LOG"

    echo "  Copying scripts to ~/scripts..."

    # Copy vm-setup.sh
    if [ -f "$SCRIPT_DIR/vm-setup.sh" ]; then
        scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "$SCRIPT_DIR/vm-setup.sh" "${VM_USER}@${vm_ip}":~/scripts/ 2>> "$CAL_LOG"
        echo "    ‚úì vm-setup.sh"
    else
        echo "    ‚ö† vm-setup.sh not found"
    fi

    # Copy vm-auth.sh
    if [ -f "$SCRIPT_DIR/vm-auth.sh" ]; then
        scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "$SCRIPT_DIR/vm-auth.sh" "${VM_USER}@${vm_ip}":~/scripts/ 2>> "$CAL_LOG"
        echo "    ‚úì vm-auth.sh"
    else
        echo "    ‚ö† vm-auth.sh not found"
    fi

    # Make scripts executable
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "chmod +x ~/scripts/*.sh" 2>> "$CAL_LOG"

    # Add ~/scripts to PATH in .zshrc if not already present
    echo "  Adding ~/scripts to PATH in .zshrc..."
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "if ! grep -q 'export PATH=\"\$HOME/scripts:\$PATH\"' ~/.zshrc; then echo 'export PATH=\"\$HOME/scripts:\$PATH\"' >> ~/.zshrc; echo '    ‚úì Added to PATH'; else echo '    ‚úì Already in PATH'; fi" 2>> "$CAL_LOG"

    echo "  ‚úì Scripts folder configured"
}

# Unlock keychain for SSH sessions (enables agent authentication)
# Returns 0 even on failure to avoid blocking SSH connection
unlock_keychain() {
    local vm_ip="$1"

    echo "  Unlocking keychain for SSH access..."
    if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${vm_ip}" "security unlock-keychain -p '${VM_PASSWORD}' login.keychain 2>/dev/null"; then
        echo "  ‚úì Keychain unlocked"
        return 0
    else
        echo "  ‚ö† Could not unlock keychain (may already be unlocked)"
        return 0
    fi
}

# NOTE: SSH commands throughout this file use similar patterns
# TODO: Future refactoring opportunity - create ssh_to_vm() helper function
# to reduce duplication of: -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null
# However, this would trade off code clarity for DRYness - evaluate trade-offs

# Test if VM can reach github.com (for auto mode)
test_vm_connectivity() {
    local vm_ip="$1"

    echo "  Testing VM network connectivity to github.com..."
    if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${vm_ip}" "curl -s --connect-timeout 5 -I https://github.com 2>&1 | grep -q 'HTTP'" 2>> "$CAL_LOG"; then
        echo "  ‚úì VM can reach github.com directly"
        return 0
    else
        echo "  ‚ö† VM cannot reach github.com (needs SOCKS tunnel)"
        return 1
    fi
}

# Check if host SSH server is available (required for SOCKS tunnel)
check_host_ssh() {
    echo "  Checking if host SSH server is available..."

    # Check if SSH is listening on the host gateway IP
    if nc -z -w 2 "$HOST_GATEWAY" 22 2>/dev/null; then
        echo "  ‚úì Host SSH server is running"
        return 0
    else
        echo "  ‚ö† Host SSH server not available on $HOST_GATEWAY:22"
        echo ""
        echo "  SOCKS tunnel requires SSH server on host Mac."
        echo "  To enable Remote Login (SSH):"
        echo "    System Settings ‚Üí General ‚Üí Sharing ‚Üí Remote Login (ON)"
        echo "  Or via command line:"
        echo "    sudo systemsetup -setremotelogin on"
        echo ""
        echo "  Skipping SOCKS tunnel setup."
        echo "[$(date)] Host SSH not available on $HOST_GATEWAY:22" >> "$CAL_LOG"
        return 1
    fi
}

# Setup SSH key in VM for SOCKS tunnel back to host
# Security: Key is added with restrictions to limit what VM can do on host
setup_vm_ssh_key() {
    local vm_ip="$1"

    echo "  Setting up VM SSH key for SOCKS tunnel..."

    # Check if host SSH is available first
    if ! check_host_ssh; then
        return 1
    fi

    # Check if VM already has an SSH key
    local has_key
    has_key=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "[ -f ~/.ssh/id_ed25519 ] && echo yes || echo no" 2>> "$CAL_LOG")

    if [ "$has_key" = "yes" ]; then
        echo "  ‚úì VM SSH key already exists"
    else
        echo "  Generating SSH key in VM..."
        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "${VM_USER}@${vm_ip}" "ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519 -N '' -C 'cal-vm-socks' >/dev/null 2>&1" 2>> "$CAL_LOG"
        echo "  ‚úì VM SSH key generated"
    fi

    # Get the VM's public key
    local vm_pubkey
    vm_pubkey=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "cat ~/.ssh/id_ed25519.pub" 2>> "$CAL_LOG")

    if [ -z "$vm_pubkey" ]; then
        echo "  ‚ö† Could not retrieve VM public key"
        echo "[$(date)] Failed to retrieve VM public key from $vm_ip" >> "$CAL_LOG"
        return 1
    fi

    # Get the key fingerprint for comparison (more reliable than comment)
    local vm_key_fp
    vm_key_fp=$(echo "$vm_pubkey" | ssh-keygen -lf - 2>/dev/null | awk '{print $2}')

    if [ -z "$vm_key_fp" ]; then
        echo "  ‚ö† Could not calculate key fingerprint"
        echo "[$(date)] Failed to calculate fingerprint for VM key" >> "$CAL_LOG"
        return 1
    fi

    # Check if this specific key is already in host's authorized_keys (by fingerprint)
    mkdir -p ~/.ssh
    chmod 700 ~/.ssh
    touch ~/.ssh/authorized_keys
    chmod 600 ~/.ssh/authorized_keys

    local key_exists=false
    if [ -s ~/.ssh/authorized_keys ]; then
        # Check each key's fingerprint (suppress any debug output)
        while IFS= read -r line; do
            [ -z "$line" ] && continue
            [[ "$line" =~ ^# ]] && continue
            local existing_fp=""
            existing_fp=$(echo "$line" | awk '{print $1, $2}' | ssh-keygen -lf - 2>/dev/null | awk '{print $2}') 2>/dev/null
            if [ "$existing_fp" = "$vm_key_fp" ]; then
                key_exists=true
                break
            fi
        done < ~/.ssh/authorized_keys 2>/dev/null
    fi

    if [ "$key_exists" = "true" ]; then
        echo "  ‚úì VM key already in host authorized_keys (fingerprint: ${vm_key_fp:0:16}...)"
    else
        echo "  Adding VM key to host authorized_keys (with restrictions)..."
        # Add key with security restrictions:
        # - restrict: Most restrictive option, prevents shell access
        # - port-forwarding: Allow port forwarding (needed for SOCKS -D)
        # - command="/usr/bin/true": Command runs but does nothing (bypassed by -N flag)
        # The key can ONLY be used for SSH SOCKS tunneling (-D), not interactive access
        local restricted_key="restrict,port-forwarding,command=\"/usr/bin/true\" ${vm_pubkey}"
        echo "$restricted_key" >> ~/.ssh/authorized_keys
        echo "  ‚úì VM key added to host (restricted: SOCKS only, no shell access)"
        echo "[$(date)] Added restricted VM key with fingerprint $vm_key_fp" >> "$CAL_LOG"
    fi

    # Pre-populate host's SSH key in VM's known_hosts for secure connections
    echo "  Setting up host key verification in VM..."
    setup_vm_known_hosts "$vm_ip"

    # Test SSH from VM to host
    echo "  Testing VM‚ÜíHost SSH connection..."
    if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${vm_ip}" "ssh -o StrictHostKeyChecking=yes -o ConnectTimeout=5 ${HOST_USER}@${HOST_GATEWAY} 'echo ok'" 2>> "$CAL_LOG"; then
        echo "  ‚úì VM can SSH to host (with host key verification)"
        return 0
    else
        echo "  ‚ö† VM‚ÜíHost SSH test failed (tunnel may still work)"
        echo "[$(date)] VM‚ÜíHost SSH test failed" >> "$CAL_LOG"
        return 0
    fi
}

# Pre-populate VM's known_hosts with host's SSH key
# This enables StrictHostKeyChecking=yes for security
setup_vm_known_hosts() {
    local vm_ip="$1"

    # Get host's SSH public keys
    local host_keys
    host_keys=$(ssh-keyscan -H "$HOST_GATEWAY" 2>/dev/null)

    if [ -z "$host_keys" ]; then
        echo "  ‚ö† Could not scan host SSH keys"
        echo "[$(date)] ssh-keyscan failed for $HOST_GATEWAY" >> "$CAL_LOG"
        return 1
    fi

    # Add host keys to VM's known_hosts
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "mkdir -p ~/.ssh && chmod 700 ~/.ssh && cat >> ~/.ssh/known_hosts" <<< "$host_keys" 2>> "$CAL_LOG"

    echo "  ‚úì Host SSH keys added to VM's known_hosts"
}

# Start HTTP-to-SOCKS bridge in VM (for Node.js tools like opencode)
# Note: gost must be installed first (via vm-setup.sh)
start_http_proxy_bridge() {
    local vm_ip="$1"
    local silent="${2:-false}"  # Pass "true" to suppress warnings (e.g., during init before gost is installed)

    # Check if HTTP bridge is already running
    local bridge_running
    bridge_running=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "nc -z localhost ${HTTP_PROXY_PORT} 2>/dev/null && echo yes || echo no" 2>> "$CAL_LOG")

    if [ "$bridge_running" = "yes" ]; then
        [ "$silent" != "true" ] && echo "  ‚úì HTTP bridge already running on port ${HTTP_PROXY_PORT}"
        return 0
    fi

    # Check if gost is installed
    local has_gost
    has_gost=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "command -v gost >/dev/null && echo yes || echo no" 2>> "$CAL_LOG")

    if [ "$has_gost" != "yes" ]; then
        # Only warn if not in silent mode (during init, gost isn't installed yet)
        [ "$silent" != "true" ] && echo "  ‚ö† gost not installed in VM - HTTP bridge unavailable"
        echo "[$(date)] gost not found in VM" >> "$CAL_LOG"
        # Return 0 in silent mode to not trigger set -e exit during init
        [ "$silent" = "true" ] && return 0
        return 1
    fi

    [ "$silent" != "true" ] && echo "  Starting HTTP-to-SOCKS bridge..."

    # Start gost HTTP-to-SOCKS bridge (silent - logs to file in VM, with PID tracking)
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "nohup gost -L 'http://:${HTTP_PROXY_PORT}' -F 'socks5://localhost:${SOCKS_PORT}' >> ~/.cal-http-proxy.log 2>&1 & echo \$! > ~/.cal-http-proxy.pid; disown" 2>> "$CAL_LOG"

    # Wait for bridge to start (2s allows gost to initialize and bind to port)
    sleep 2
    bridge_running=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "nc -z localhost ${HTTP_PROXY_PORT} 2>/dev/null && echo yes || echo no" 2>> "$CAL_LOG")

    if [ "$bridge_running" = "yes" ]; then
        [ "$silent" != "true" ] && echo "  ‚úì HTTP bridge started (SOCKS :${SOCKS_PORT} ‚Üí HTTP :${HTTP_PROXY_PORT})"
        return 0
    else
        [ "$silent" != "true" ] && echo "  ‚ö† HTTP bridge failed to start"
        echo "[$(date)] HTTP bridge failed to start" >> "$CAL_LOG"
        return 1
    fi
}

# Start SOCKS tunnel in VM (if not already running)
# This provides reliable network connectivity for restrictive corporate networks
start_socks_tunnel() {
    local vm_ip="$1"

    echo "  Checking SOCKS tunnel..."

    # Check if tunnel is already running
    local tunnel_running
    tunnel_running=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "nc -z localhost ${SOCKS_PORT} 2>/dev/null && echo yes || echo no" 2>> "$CAL_LOG")

    if [ "$tunnel_running" = "yes" ]; then
        echo "  ‚úì SOCKS tunnel already running on port ${SOCKS_PORT}"
        # Try to start HTTP bridge (silent if gost not installed - e.g., during init)
        start_http_proxy_bridge "$vm_ip" "true"
        show_socks_cow "$vm_ip"
        return 0
    fi

    # Check if port is available in VM
    local port_check
    port_check=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "lsof -i :${SOCKS_PORT} 2>/dev/null | head -2" 2>> "$CAL_LOG")

    if [ -n "$port_check" ]; then
        echo "  ‚ö† Port ${SOCKS_PORT} already in use in VM:"
        echo "$port_check" | sed 's/^/    /'
        echo "[$(date)] Port ${SOCKS_PORT} already in use: $port_check" >> "$CAL_LOG"
        return 1
    fi

    echo "  Starting SOCKS tunnel (VM‚ÜíHost on port ${SOCKS_PORT})..."

    # Start the SSH SOCKS tunnel in background
    # Uses StrictHostKeyChecking=yes since we pre-populated known_hosts
    local tunnel_result
    tunnel_result=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "ssh -D ${SOCKS_PORT} -f -N -o StrictHostKeyChecking=yes -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -o ExitOnForwardFailure=yes ${HOST_USER}@${HOST_GATEWAY} 2>&1" 2>> "$CAL_LOG")

    local ssh_exit=$?
    if [ $ssh_exit -ne 0 ]; then
        echo "  ‚ö† SSH tunnel command failed"
        echo "[$(date)] Tunnel SSH failed (exit $ssh_exit): $tunnel_result" >> "$CAL_LOG"
    fi

    # Wait for tunnel to be ready (max 10s - SSH tunnel typically ready in 1-2s)
    # Timeout allows for slow SSH handshakes or network issues without hanging indefinitely
    local count=0
    local max_wait=10
    while [ $count -lt $max_wait ]; do
        sleep 1
        count=$((count + 1))
        tunnel_running=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "${VM_USER}@${vm_ip}" "nc -z localhost ${SOCKS_PORT} 2>/dev/null && echo yes || echo no" 2>> "$CAL_LOG")
        if [ "$tunnel_running" = "yes" ]; then
            echo "  ‚úì SOCKS tunnel started successfully"
            # Try to start HTTP bridge (silent if gost not installed - e.g., during init)
            start_http_proxy_bridge "$vm_ip" "true"
            show_socks_cow "$vm_ip"
            return 0
        fi
    done

    echo "  ‚ö† SOCKS tunnel may not have started (check ~/.cal-bootstrap.log)"
    echo "[$(date)] Tunnel start timeout after ${max_wait}s" >> "$CAL_LOG"
    return 1
}

# Show the celebratory cow when SOCKS is working
show_socks_cow() {
    local vm_ip="$1"

    # Test that SOCKS actually works
    local test_result
    test_result=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "curl -s --connect-timeout 5 --socks5-hostname localhost:${SOCKS_PORT} -I https://www.google.com 2>&1 | grep -q '200' && echo yes || echo no" 2>> "$CAL_LOG")

    if [ "$test_result" = "yes" ]; then
        echo ""
        echo " _____________________"
        echo "< SOCKS tunnel works! >"
        echo " ---------------------"
        echo "        \\   ^__^"
        echo "         \\  (oo)\\_______"
        echo "            (__)\\       )\\/\\"
        echo "                ||----w |"
        echo "                ||     ||"
        echo ""
    else
        echo "[$(date)] SOCKS connectivity test failed" >> "$CAL_LOG"
    fi
}

# Determine whether to enable SOCKS based on mode
should_enable_socks() {
    local vm_ip="$1"

    case "$SOCKS_MODE" in
        on)
            echo "  SOCKS mode: on (forced)"
            return 0
            ;;
        off)
            echo "  SOCKS mode: off (disabled)"
            return 1
            ;;
        auto)
            echo "  SOCKS mode: auto (testing connectivity...)"
            if test_vm_connectivity "$vm_ip"; then
                echo "  ‚Üí Network OK, SOCKS tunnel not needed"
                return 1
            else
                echo "  ‚Üí Network restricted, enabling SOCKS tunnel"
                return 0
            fi
            ;;
        *)
            echo "  ‚ö† Invalid SOCKS_MODE='$SOCKS_MODE', defaulting to auto"
            SOCKS_MODE="auto"
            should_enable_socks "$vm_ip"
            ;;
    esac
}

# === INIT MODE ===
do_init() {
    echo ""
    echo "CAL Bootstrap - Initialize"
    echo "==========================="
    echo ""
    
    # Step 1: Create cal-clean from base image
    echo "Step 1: Create $VM_CLEAN"
    if vm_exists "$VM_CLEAN"; then
        echo "  $VM_CLEAN already exists, skipping"
    else
        echo "  Cloning from ghcr.io/cirruslabs/macos-sequoia-base:latest..."
        echo "  (This downloads ~25GB, may take a while)"
        "$TART" clone ghcr.io/cirruslabs/macos-sequoia-base:latest "$VM_CLEAN"
        echo "  Setting VM resources (4 CPU, 8GB RAM, 80GB disk)..."
        "$TART" set "$VM_CLEAN" --cpu 4 --memory 8192 --disk-size 80
        echo "  $VM_CLEAN created"
    fi
    
    # Step 2: Create cal-dev from cal-clean
    echo ""
    echo "Step 2: Create $VM_DEV"
    if vm_exists "$VM_DEV"; then
        echo "  $VM_DEV already exists, skipping"
    else
        echo "  Cloning from $VM_CLEAN..."
        "$TART" clone "$VM_CLEAN" "$VM_DEV"
        echo "  $VM_DEV created"
    fi
    
    # Step 3: Start cal-dev and setup
    echo ""
    echo "Step 3: Setup $VM_DEV"
    if ! start_vm_background "$VM_DEV"; then
        echo "  Failed to start VM"
        exit 1
    fi
    
    # Step 4: Setup SSH keys (host‚ÜíVM)
    echo ""
    echo "Step 4: Setup SSH keys (host‚ÜíVM)"
    setup_ssh_keys "$VM_IP"

    # Step 5: Setup SOCKS tunnel (VM‚ÜíHost for network access)
    echo ""
    echo "Step 5: Setup SOCKS tunnel for network access"
    if should_enable_socks "$VM_IP"; then
        setup_vm_ssh_key "$VM_IP"
        start_socks_tunnel "$VM_IP"
    else
        echo "  ‚úì SOCKS tunnel skipped (not needed)"
    fi

    # Step 6: Setup scripts folder first
    echo ""
    echo "Step 6: Setup scripts folder"
    setup_scripts_folder "$VM_IP"

    # Step 7: Run vm-setup from ~/scripts
    echo ""
    echo "Step 7: Install tools"
    run_vm_setup "$VM_IP"

    # Step 8: Prompt user for manual setup
    echo ""
    echo "============================================"
    echo "Manual setup required in VM"
    echo "============================================"
    echo ""
    echo "Opening tmux session in VM to run authentication..."
    echo ""

    # Automatically SSH into the VM with tmux and run vm-auth.sh
    ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${VM_IP}" "TERM=xterm-256color /opt/homebrew/bin/tmux new-session -A -s setup 'zsh ~/scripts/vm-auth.sh'"

    echo ""
    echo "Continuing with setup..."

    # Step 9: Create cal-init
    echo ""
    echo "Step 9: Create $VM_INIT snapshot"
    
    # Stop VM first
    CLEANUP_VM=false
    echo "  Stopping $VM_DEV..."
    "$TART" stop "$VM_DEV" 2>/dev/null || true
    kill "$TART_PID" 2>/dev/null || true
    sleep 2
    
    # Delete existing if present
    if vm_exists "$VM_INIT"; then
        if [ "$SKIP_CONFIRM" = true ]; then
            "$TART" delete "$VM_INIT"
        else
            echo "  $VM_INIT already exists. Replace it? (y/N)"
            read -r -k 1 reply
            echo ""
            if [[ $reply =~ ^[Yy]$ ]]; then
                "$TART" delete "$VM_INIT"
            else
                echo "  Keeping existing $VM_INIT"
                echo ""
                echo "Bootstrap complete!"
                return 0
            fi
        fi
    fi
    
    echo "  Creating $VM_INIT from $VM_DEV..."
    "$TART" clone "$VM_DEV" "$VM_INIT"
    echo "  $VM_INIT created"
    
    echo ""
    echo "Bootstrap complete!"
    echo ""
    echo "VMs created:"
    printf "  %-17s - Base macOS image\n" "$VM_CLEAN"
    printf "  %-17s - Development VM (use this)\n" "$VM_DEV"
    printf "  %-17s - Snapshot with tools configured\n" "$VM_INIT"
    echo ""
    echo "Next: Run './cal-bootstrap --run' to start developing"
}

# === RUN MODE ===
do_run() {
    echo ""
    echo "CAL Bootstrap - Run"
    echo "===================="
    echo ""
    
    local vm_to_run="$VM_DEV"
    
    # Check if VM exists
    if ! vm_exists "$vm_to_run"; then
        echo "$vm_to_run does not exist."
        echo ""
        echo "Run './cal-bootstrap --init' to set up the environment."
        exit 1
    fi
    
    # If already running, just SSH in
    if vm_running "$vm_to_run"; then
        echo "$vm_to_run is already running."
        VM_IP=$("$TART" ip "$vm_to_run" 2>/dev/null || echo "")
        if [ -n "$VM_IP" ]; then
            echo ""
            # Setup and start SOCKS tunnel if needed
            if should_enable_socks "$VM_IP"; then
                # Ensure VM SSH key is set up (idempotent - safe to run multiple times)
                if setup_vm_ssh_key "$VM_IP"; then
                    start_socks_tunnel "$VM_IP" || echo "  ‚ö† SOCKS tunnel failed to start (see ~/.cal-bootstrap.log)"
                    # Start HTTP bridge for Node.js tools (gost should be installed)
                    start_http_proxy_bridge "$VM_IP" || true
                else
                    echo "  ‚ö† Skipping SOCKS tunnel (setup failed)"
                fi
            fi
            unlock_keychain "$VM_IP"
            echo ""
            echo "Connecting via SSH with tmux..."
            echo "üí° tmux session 'cal' (Ctrl+b d to detach, Ctrl+b ? for help)"
            echo ""
            ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                "${VM_USER}@${VM_IP}" "TERM=xterm-256color /opt/homebrew/bin/tmux new-session -A -s cal"
        else
            echo "Could not get VM IP address."
            exit 1
        fi
        exit 0
    fi
    
    # Start VM
    if ! start_vm_background "$vm_to_run"; then
        echo "Failed to start VM"
        exit 1
    fi
    
    # Don't cleanup on success
    CLEANUP_VM=false

    echo ""
    echo "$vm_to_run is running (PID: $TART_PID)"

    # Setup and start SOCKS tunnel if needed
    if should_enable_socks "$VM_IP"; then
        # Ensure VM SSH key is set up (idempotent - safe to run multiple times)
        if setup_vm_ssh_key "$VM_IP"; then
            start_socks_tunnel "$VM_IP" || echo "  ‚ö† SOCKS tunnel failed to start (see ~/.cal-bootstrap.log)"
            # Start HTTP bridge for Node.js tools (gost should be installed)
            start_http_proxy_bridge "$VM_IP" || true
        else
            echo "  ‚ö† Skipping SOCKS tunnel (setup failed)"
        fi
    fi

    # Unlock keychain for SSH access
    unlock_keychain "$VM_IP"

    echo ""
    echo "VNC:   open vnc://${VM_IP}"
    echo "Stop:  $TART stop $vm_to_run"
    echo ""
    echo "üí° If agent login fails, use Screen Sharing (standard mode, not High Performance):"
    echo "   open vnc://${VM_IP} ‚Üí Authenticate agent ‚Üí Return to terminal"
    echo ""
    echo "Connecting via SSH with tmux..."
    echo "üí° tmux session 'cal' (Ctrl+b d to detach, Ctrl+b ? for help)"
    echo ""
    
    # SSH into the VM with tmux (always)
    ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${VM_IP}" "TERM=xterm-256color /opt/homebrew/bin/tmux new-session -A -s cal"
}

# === STOP MODE ===
do_stop() {
    echo ""
    echo "CAL Bootstrap - Stop"
    echo "===================="
    echo ""

    if ! vm_exists "$VM_DEV"; then
        echo "$VM_DEV does not exist."
        exit 1
    fi

    if ! vm_running "$VM_DEV"; then
        echo "$VM_DEV is not running."
        exit 0
    fi

    echo "Stopping $VM_DEV..."
    "$TART" stop "$VM_DEV"
    echo ""
    echo "$VM_DEV stopped."
}

# === RESTART MODE ===
do_restart() {
    echo ""
    echo "CAL Bootstrap - Restart"
    echo "========================="
    echo ""

    if ! vm_exists "$VM_DEV"; then
        echo "$VM_DEV does not exist."
        echo ""
        echo "Run './cal-bootstrap --init' to set up the environment."
        exit 1
    fi

    # Stop if running
    if vm_running "$VM_DEV"; then
        echo "Stopping $VM_DEV..."
        "$TART" stop "$VM_DEV"
        sleep 2
        echo ""
    fi

    # Start VM
    if ! start_vm_background "$VM_DEV"; then
        echo "Failed to start VM"
        exit 1
    fi

    # Don't cleanup on success
    CLEANUP_VM=false

    echo ""
    echo "$VM_DEV is running (PID: $TART_PID)"

    # Setup and start SOCKS tunnel if needed
    if should_enable_socks "$VM_IP"; then
        # Ensure VM SSH key is set up (idempotent - safe to run multiple times)
        if setup_vm_ssh_key "$VM_IP"; then
            start_socks_tunnel "$VM_IP" || echo "  ‚ö† SOCKS tunnel failed to start (see ~/.cal-bootstrap.log)"
            # Start HTTP bridge for Node.js tools (gost should be installed)
            start_http_proxy_bridge "$VM_IP" || true
        else
            echo "  ‚ö† Skipping SOCKS tunnel (setup failed)"
        fi
    fi

    # Unlock keychain for SSH access
    unlock_keychain "$VM_IP"

    echo ""
    echo "VNC:   open vnc://${VM_IP}"
    echo "Stop:  $TART stop $VM_DEV"
    echo ""
    echo "üí° If agent login fails, use Screen Sharing (standard mode, not High Performance):"
    echo "   open vnc://${VM_IP} ‚Üí Authenticate agent ‚Üí Return to terminal"
    echo ""
    echo "Connecting via SSH with tmux..."
    echo "üí° tmux session 'cal' (Ctrl+b d to detach, Ctrl+b ? for help)"
    echo ""

    # SSH into the VM with tmux (always)
    ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${VM_IP}" "TERM=xterm-256color /opt/homebrew/bin/tmux new-session -A -s cal"
}

# === SNAPSHOT MODE ===
do_snapshot() {
    local action="$1"
    local name="$2"
    
    echo ""
    echo "CAL Bootstrap - Snapshot"
    echo "========================="
    echo ""
    
    case "$action" in
        create)
            if [ -z "$name" ]; then
                echo "Usage: ./cal-bootstrap --snapshot create <name>"
                exit 1
            fi
            
            # Stop VM if running
            stop_vm "$VM_DEV"
            
            local snapshot_name="${VM_DEV}-${name}"
            
            if vm_exists "$snapshot_name"; then
                if [ "$SKIP_CONFIRM" = true ]; then
                    "$TART" delete "$snapshot_name"
                else
                    echo "Snapshot $snapshot_name already exists. Replace? (y/N)"
                    read -r -k 1 reply
                    echo ""
                    if [[ $reply =~ ^[Yy]$ ]]; then
                        "$TART" delete "$snapshot_name"
                    else
                        echo "Aborted"
                        exit 1
                    fi
                fi
            fi
            
            echo "Creating snapshot: $snapshot_name"
            "$TART" clone "$VM_DEV" "$snapshot_name"
            echo ""
            echo "Snapshot created: $snapshot_name"
            echo ""
            echo "Restore with: ./cal-bootstrap --snapshot restore $name"
            ;;
            
        restore)
            if [ -z "$name" ]; then
                echo "Usage: ./cal-bootstrap --snapshot restore <name>"
                echo ""
                do_snapshot list
                exit 1
            fi

            # Resolve short name to full name
            local restore_from
            restore_from=$(resolve_vm_name "$name")

            if [ -z "$restore_from" ]; then
                # Try with prefix
                restore_from=$(resolve_vm_name "${VM_DEV}-${name}")
            fi

            if [ -z "$restore_from" ]; then
                echo "VM '$name' not found"
                echo ""
                do_snapshot list
                exit 1
            fi

            # Can't restore from cal-dev to cal-dev
            if [ "$restore_from" = "$VM_DEV" ]; then
                echo "Cannot restore $VM_DEV from itself"
                exit 1
            fi

            # Check if cal-dev exists (early exit if missing)
            if ! vm_exists "$VM_DEV"; then
                echo "‚ö†Ô∏è  $VM_DEV does not exist."
                echo ""
                echo "Cannot restore to a non-existent VM."
                echo ""
                echo "You can:"
                echo "  1. Re-run: ./scripts/cal-bootstrap --init"
                echo "  2. Or create manually: tart clone cal-clean $VM_DEV"
                echo ""
                exit 1
            fi

            # Always check for git changes - boot VM if needed
            local has_uncommitted=false
            local has_unpushed=false
            local uncommitted_check=""
            local unpushed_check=""
            local we_started_vm=false

            # Start VM if not running
            if ! vm_running "$VM_DEV"; then
                echo "Starting $VM_DEV to check for uncommitted changes..."
                if start_vm_background "$VM_DEV"; then
                    we_started_vm=true
                else
                    echo "  ‚ö† Could not start VM to check for git changes"
                    echo "  Proceeding without git check..."
                fi
            fi

            # Check for git changes if VM is running
            if vm_running "$VM_DEV"; then
                echo "Checking for git changes in $VM_DEV..."
                local vm_ip
                vm_ip=$("$TART" ip "$VM_DEV" 2>/dev/null || echo "")

                if [ -n "$vm_ip" ]; then
                    # Check for uncommitted changes (search common dev directories + home with depth limit)
                    uncommitted_check=$(ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                        "${VM_USER}@${vm_ip}" 'for gitdir in $(find ~/workspace ~/projects ~/repos ~/code 2>/dev/null -name ".git" -type d 2>/dev/null; find ~ -maxdepth 2 -name ".git" -type d 2>/dev/null) | sort -u; do dir=$(dirname "$gitdir"); (cd "$dir" 2>/dev/null && [ -n "$(git status --porcelain 2>/dev/null)" ] && echo "$dir"); done' 2>/dev/null || echo "")

                    if [ -n "$uncommitted_check" ]; then
                        has_uncommitted=true
                    fi

                    # Check for unpushed commits (requires upstream tracking to be set)
                    unpushed_check=$(ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                        "${VM_USER}@${vm_ip}" 'for gitdir in $(find ~/workspace ~/projects ~/repos ~/code 2>/dev/null -name ".git" -type d 2>/dev/null; find ~ -maxdepth 2 -name ".git" -type d 2>/dev/null) | sort -u; do dir=$(dirname "$gitdir"); (cd "$dir" 2>/dev/null && branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null); if [ "$branch" != "HEAD" ] && git rev-parse "$branch@{u}" >/dev/null 2>&1 && [ -n "$(git log "@{u}.." --oneline 2>/dev/null)" ]; then echo "$dir"; fi); done' 2>/dev/null || echo "")

                    if [ -n "$unpushed_check" ]; then
                        has_unpushed=true
                    fi

                    # Show warnings
                    if [ "$has_uncommitted" = true ] || [ "$has_unpushed" = true ]; then
                        echo ""
                        echo "‚ö†Ô∏è  WARNING: Found git changes that will be lost!"
                        echo ""

                        if [ "$has_uncommitted" = true ]; then
                            echo "Uncommitted changes in:"
                            echo "$uncommitted_check" | while read -r repo; do
                                [ -n "$repo" ] && echo "  - $repo"
                            done
                            echo ""
                        fi

                        if [ "$has_unpushed" = true ]; then
                            echo "Unpushed commits in:"
                            echo "$unpushed_check" | while read -r repo; do
                                [ -n "$repo" ] && echo "  - $repo"
                            done
                            echo ""
                        fi

                        echo "These changes will be lost if you restore from snapshot."
                    else
                        echo "  ‚úì No uncommitted or unpushed changes found"
                    fi
                fi
            fi

            # Stop VM if we started it just for the git check
            if [ "$we_started_vm" = true ]; then
                echo ""
                echo "Stopping $VM_DEV..."
                stop_vm "$VM_DEV"
                CLEANUP_VM=false
            fi

            # Single confirmation prompt (after showing git warnings if any)
            if [ "$SKIP_CONFIRM" = false ]; then
                echo ""
                echo "This will replace $VM_DEV with $restore_from"
                echo "All changes in $VM_DEV will be lost!"
                echo ""
                echo "Continue? (y/N)"
                read -r -k 1 reply
                echo ""
                if [[ ! $reply =~ ^[Yy]$ ]]; then
                    echo "Aborted"
                    exit 1
                fi
            fi

            # Stop and delete current VM
            stop_vm "$VM_DEV"

            # Delete VM
            if vm_exists "$VM_DEV"; then
                echo "Deleting $VM_DEV..."
                if ! "$TART" delete "$VM_DEV"; then
                    echo ""
                    echo "‚ö†Ô∏è  Failed to delete $VM_DEV"
                    echo ""
                    echo "This can happen if:"
                    echo "  ‚Ä¢ VM is in an inconsistent state"
                    echo "  ‚Ä¢ Tart is holding a lock on the VM"
                    echo "  ‚Ä¢ Another process is using the VM"
                    echo ""
                    echo "You may need to delete it manually:"
                    echo "  tart delete $VM_DEV"
                    echo ""
                    echo "Or restart your machine if Tart is locked."
                    echo ""
                    echo "Aborting restore."
                    exit 1
                fi
            fi

            # Restore from snapshot
            echo "Restoring from $restore_from..."
            "$TART" clone "$restore_from" "$VM_DEV"
            
            echo ""
            echo "Restored $VM_DEV from $restore_from"
            echo ""
            
            # Give different instructions based on what was restored
            if [ "$restore_from" = "$VM_CLEAN" ]; then
                echo "‚ö†Ô∏è  Restored from clean base image (no tools installed)"
                echo ""
                echo "Run './cal-bootstrap --init' to set up tools and agents"
            else
                echo "Run './cal-bootstrap --run' to start the VM"
            fi
            ;;
            
        list)
            # Check for short name collisions
            local collision_check
            collision_check=$("$TART" list | awk 'NR==1 {next} {
                full_name = $2
                source = $1

                # Create short name
                short_name = full_name
                if (source == "OCI") {
                    gsub(/ghcr.io\/cirruslabs\/macos-/, "", short_name)
                    if (match(short_name, /@sha256:/)) {
                        short_name = substr(short_name, 1, RSTART-1) "-digest"
                    }
                }

                print short_name
            }' | sort | uniq -d)

            if [ -n "$collision_check" ]; then
                echo "‚ö†Ô∏è  WARNING: Short name collisions detected!"
                echo "   Use full names for these VMs:"
                echo ""
            fi

            # List VMs (simplified output - show all VMs/snapshots together)
            "$TART" list | awk -v collisions="$collision_check" '
                BEGIN {
                    # Build collision map
                    split(collisions, coll_array, "\n")
                    for (i in coll_array) {
                        collision_map[coll_array[i]] = 1
                    }
                }
                NR==1 {next}
                {
                    full_name = $2
                    source = $1
                    state = $NF

                    # Create short name for display
                    short_name = full_name
                    if (source == "OCI") {
                        gsub(/ghcr.io\/cirruslabs\/macos-/, "", short_name)
                        if (match(short_name, /@sha256:/)) {
                            short_name = substr(short_name, 1, RSTART-1) "-digest"
                        }
                    }

                    # Show full name if collision
                    if (short_name in collision_map) {
                        printf "  %s (%s)\n", full_name, state
                    } else {
                        printf "  %s (%s)\n", short_name, state
                    }
                }'
            echo ""
            echo "üí° All VMs and snapshots are listed. Use short names unless collision detected."
            echo ""
            exit 0
            ;;
            
        delete)
            if [ -z "$name" ]; then
                echo "Usage: ./cal-bootstrap --snapshot delete <name>"
                echo ""
                do_snapshot list
                exit 1
            fi
            
            # Resolve short name to full name
            local vm_to_delete
            vm_to_delete=$(resolve_vm_name "$name")
            
            if [ -z "$vm_to_delete" ]; then
                # Try with prefix
                vm_to_delete=$(resolve_vm_name "${VM_DEV}-${name}")
            fi
            
            if [ -z "$vm_to_delete" ]; then
                echo "VM '$name' not found"
                echo ""
                do_snapshot list
                exit 1
            fi
            
            # Stop if running
            stop_vm "$vm_to_delete"
            
            # Confirm (with extra warning for system VMs)
            if [ "$SKIP_CONFIRM" = false ]; then
                if [ "$vm_to_delete" = "$VM_DEV" ]; then
                    echo "‚ö†Ô∏è  WARNING: Deleting your working VM!"
                    echo ""
                    echo "This will delete $vm_to_delete permanently."
                    echo "You may want to use restore instead to reset state."
                    echo ""
                elif [ "$vm_to_delete" = "$VM_CLEAN" ]; then
                    echo "‚ö†Ô∏è  WARNING: Deleting the clean base image!"
                    echo ""
                    echo "This will delete $vm_to_delete permanently."
                    echo "You'll need to re-download (~25GB) to recreate it."
                    echo ""
                elif [ "$vm_to_delete" = "$VM_INIT" ]; then
                    echo "‚ö†Ô∏è  WARNING: Deleting the initialized snapshot!"
                    echo ""
                    echo "This will delete $vm_to_delete permanently."
                    echo "You'll need to run --init again to recreate it."
                    echo ""
                fi
                echo "Delete $vm_to_delete?"
                echo ""
                echo "Continue? (y/N)"
                read -r -k 1 reply
                echo ""
                if [[ ! $reply =~ ^[Yy]$ ]]; then
                    echo "Aborted"
                    exit 1
                fi
            fi
            
            echo "Deleting $vm_to_delete..."
            "$TART" delete "$vm_to_delete"
            echo ""
            echo "Deleted: $vm_to_delete"
            ;;
            
        *)
            echo "Usage: ./cal-bootstrap --snapshot <list|create|restore|delete> [name]"
            echo ""
            echo "Examples:"
            echo "  ./cal-bootstrap --snapshot list"
            echo "  ./cal-bootstrap --snapshot create before-refactor"
            echo "  ./cal-bootstrap --snapshot restore before-refactor"
            echo "  ./cal-bootstrap --snapshot delete before-refactor"
            exit 1
            ;;
    esac
}

# === MAIN ===

# Parse arguments
MODE=""
SKIP_CONFIRM=false
SNAPSHOT_ACTION=""
SNAPSHOT_NAME=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --init|-i)
            MODE="init"
            shift
            ;;
        --run)
            MODE="run"
            shift
            ;;
        --restart|-r)
            MODE="restart"
            shift
            ;;
        --stop|-s)
            MODE="stop"
            shift
            ;;
        --snapshot|-S)
            MODE="snapshot"
            shift
            SNAPSHOT_ACTION="${1:-}"
            [[ $# -gt 0 ]] && shift
            SNAPSHOT_NAME="${1:-}"
            [[ $# -gt 0 ]] && shift
            ;;
        --socks)
            shift
            SOCKS_MODE="${1:-auto}"
            if [[ ! "$SOCKS_MODE" =~ ^(on|off|auto)$ ]]; then
                echo "Error: --socks must be 'on', 'off', or 'auto'"
                echo "Got: '$SOCKS_MODE'"
                exit 1
            fi
            shift
            ;;
        --yes|-y)
            SKIP_CONFIRM=true
            shift
            ;;
        --help|-h)
            echo "CAL Bootstrap - VM Environment Setup"
            echo ""
            echo "Usage: ./cal-bootstrap [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --init, -i                    Initialize VM environment"
            echo "  --run                         Run cal-dev with tmux (default if VMs exist)"
            echo "  --restart, -r                 Restart cal-dev and connect with tmux"
            echo "  --stop, -s                    Stop cal-dev"
            echo "  --snapshot, -S list           List available snapshots"
            echo "  --snapshot, -S create <name>  Create a named snapshot"
            echo "  --snapshot, -S restore <name> Restore from a snapshot"
            echo "  --snapshot, -S delete <name>  Delete a snapshot"
            echo "  --socks <on|off|auto>         SOCKS tunnel mode (default: auto)"
            echo "                                  on   - Always enable SOCKS tunnel"
            echo "                                  off  - Disable SOCKS tunnel"
            echo "                                  auto - Test github.com, enable if needed"
            echo "  --yes, -y                     Skip confirmation prompts"
            echo "  --help, -h                    Show this help"
            echo ""
            echo "Examples:"
            echo "  ./cal-bootstrap --init              # First-time setup"
            echo "  ./cal-bootstrap                     # Start cal-dev (auto-detects mode)"
            echo "  ./cal-bootstrap --restart           # Restart cal-dev and connect"
            echo "  ./cal-bootstrap --snapshot create pre-experiment"
            echo "  ./cal-bootstrap --snapshot restore pre-experiment"
            echo "  ./cal-bootstrap --snapshot delete pre-experiment"
            echo ""
            echo "Note: tmux is always used for persistent sessions."
            echo "      Ctrl+b d to detach, Ctrl+b ? for help"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Run './cal-bootstrap --help' for usage"
            exit 1
            ;;
    esac
done

# Find tart
TART=$(find_tart)
if [ -z "$TART" ]; then
    echo "Error: tart not found"
    echo ""
    echo "Install with: brew install cirruslabs/cli/tart"
    echo ""
    echo "Or set TART_PATH environment variable"
    exit 1
fi

# Auto-detect mode if not specified
if [ -z "$MODE" ]; then
    if vm_exists "$VM_CLEAN" && vm_exists "$VM_DEV" && vm_exists "$VM_INIT"; then
        MODE="run"
    else
        MODE="init"
    fi
    echo "Auto-detected mode: $MODE"
fi

# Execute mode
case "$MODE" in
    init)
        do_init
        ;;
    run)
        do_run
        ;;
    restart)
        do_restart
        ;;
    stop)
        do_stop
        ;;
    snapshot)
        do_snapshot "$SNAPSHOT_ACTION" "$SNAPSHOT_NAME"
        ;;
esac
