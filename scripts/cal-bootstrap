#!/bin/zsh

set -e

# Get script directory (works in zsh)
SCRIPT_DIR="${0:A:h}"

# CAL Bootstrap Script
# Usage: ./cal-bootstrap [--init|-i] [--run|-r] [--stop] [--snapshot <action> <name>]
#
# Options:
#   --init, -i      Initialize VM environment (create cal-clean, cal-dev, cal-initialised)
#   --run, -r       Run cal-dev and SSH in with tmux (default if VMs exist)
#   --restart       Restart cal-dev and SSH in with tmux
#   --stop, -s      Stop cal-dev
#   --snapshot, -S  Manage snapshots (list, create, restore, delete)
#   --yes, -y       Skip confirmation prompts
#
# Environment variables:
#   TART_PATH     - Path to tart binary
#   VM_USER       - VM username (default: admin)
#   VM_PASSWORD   - VM password (default: admin)

# VM names
VM_CLEAN="cal-clean"
VM_DEV="cal-dev"
VM_INIT="cal-initialised"

# VM credentials
VM_USER="${VM_USER:-admin}"
VM_PASSWORD="${VM_PASSWORD:-admin}"

# Cleanup tracking
CLEANUP_VM=false
CLEANUP_DONE=false
TART_PID=""

# Cleanup function
cleanup() {
    if [ "$CLEANUP_DONE" = true ]; then
        return
    fi
    CLEANUP_DONE=true
    
    if [ "$CLEANUP_VM" = true ] && [ -n "$TART_PID" ] && kill -0 "$TART_PID" 2>/dev/null; then
        echo ""
        echo "Cleaning up background VM process (PID: $TART_PID)..."
        kill "$TART_PID" 2>/dev/null || true
        wait "$TART_PID" 2>/dev/null || true
    fi
}

# Handle Ctrl-C properly
handle_interrupt() {
    echo ""
    echo "Interrupted by user"
    cleanup
    exit 130
}

trap cleanup EXIT
trap handle_interrupt INT TERM

# Find tart binary
find_tart() {
    if command -v tart &>/dev/null; then
        echo "tart"
    elif [ -n "$TART_PATH" ] && [ -x "$TART_PATH" ]; then
        echo "$TART_PATH"
    elif [ -x "./tart.app/Contents/MacOS/tart" ]; then
        echo "./tart.app/Contents/MacOS/tart"
    else
        echo ""
    fi
}

# Check if VM exists
vm_exists() {
    "$TART" list 2>/dev/null | awk -v vm="$1" 'NR>1 { if ($2 == vm) exit 0 } END { exit 1 }'
}

# Resolve VM name (short name to full name if needed)
resolve_vm_name() {
    local input_name="$1"
    
    # If VM exists with exact name, use it
    if vm_exists "$input_name"; then
        echo "$input_name"
        return 0
    fi
    
    # Try to find by short name pattern
    local matches
    matches=$("$TART" list 2>/dev/null | awk -v short="$input_name" '
        NR==1 {next}
        {
            full_name = $2
            source = $1
            
            # Create short name
            short_name = full_name
            if (source == "OCI") {
                gsub(/ghcr.io\/cirruslabs\/macos-/, "", short_name)
                if (match(short_name, /@sha256:/)) {
                    short_name = substr(short_name, 1, RSTART-1) "-digest"
                }
            }
            
            # Match short name
            if (short_name == short) {
                print full_name
            }
        }
    ')
    
    # Check for multiple matches (collision)
    local match_count
    match_count=$(echo "$matches" | grep -c '^' 2>/dev/null || echo 0)
    
    if [ "$match_count" -gt 1 ]; then
        echo "Error: Short name '$input_name' matches multiple VMs:" >&2
        echo "$matches" | sed 's/^/  - /' >&2
        echo "" >&2
        echo "Use full name instead." >&2
        return 2
    elif [ "$match_count" -eq 1 ]; then
        echo "$matches"
        return 0
    fi
    
    # Not found
    return 1
}

# Check if VM is running
vm_running() {
    "$TART" list 2>/dev/null | grep -w "$1" | grep -q "running"
}

# Stop VM if running
stop_vm() {
    local vm="$1"
    if vm_running "$vm"; then
        echo "  Stopping $vm..."
        "$TART" stop "$vm" 2>/dev/null || true
        sleep 2
    fi
}

# Start VM in background and wait for IP/SSH
start_vm_background() {
    local vm="$1"
    
    echo "  Starting $vm in background..."
    "$TART" run --no-graphics "$vm" >/dev/null 2>&1 &
    TART_PID=$!
    disown "$TART_PID" 2>/dev/null || true
    CLEANUP_VM=true
    echo "  VM started (PID: $TART_PID)"
    
    # Wait for IP
    echo "  Waiting for IP..."
    local max_wait=60
    local count=0
    VM_IP=""
    
    while [ $count -lt $max_wait ]; do
        sleep 2
        count=$((count + 2))
        VM_IP=$("$TART" ip "$vm" 2>/dev/null || echo "")
        if [ -n "$VM_IP" ]; then
            echo "  VM IP: $VM_IP"
            break
        fi
        printf "  Waiting... (%ds/%ds)\r" "$count" "$max_wait"
    done
    
    if [ -z "$VM_IP" ]; then
        echo "  Could not obtain IP after ${max_wait}s"
        return 1
    fi
    
    # Wait for SSH
    echo "  Waiting for SSH..."
    
    # Ensure sshpass is available for automated setup (install quietly if needed)
    if ! command -v sshpass &>/dev/null; then
        # Try to install sshpass silently
        brew install esolitos/ipa/sshpass &>/dev/null 2>&1 || \
        brew install hudochenkov/sshpass/sshpass &>/dev/null 2>&1 || true
    fi
    
    local has_sshpass=false
    local has_expect=false
    if command -v sshpass &>/dev/null; then
        has_sshpass=true
    elif command -v expect &>/dev/null; then
        has_expect=true
    fi
    
    count=0
    
    while [ $count -lt $max_wait ]; do
        if [ "$has_sshpass" = true ]; then
            # With sshpass: try automated password auth
            if SSHPASS="${VM_PASSWORD}" sshpass -e ssh -o ConnectTimeout=2 -o StrictHostKeyChecking=no \
                   -o UserKnownHostsFile=/dev/null -o PreferredAuthentications=password \
                   "${VM_USER}@${VM_IP}" "echo ok" &>/dev/null 2>&1; then
                echo "  SSH is ready"
                return 0
            fi
        elif [ "$has_expect" = true ]; then
            # With expect: try automated password auth
            if expect -c "
                set timeout 5
                spawn ssh -o ConnectTimeout=2 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${VM_USER}@${VM_IP} echo ok
                expect {
                    \"*assword*\" { send \"${VM_PASSWORD}\r\"; exp_continue }
                    \"ok\" { exit 0 }
                    timeout { exit 1 }
                    eof { exit 1 }
                }
            " &>/dev/null 2>&1; then
                echo "  SSH is ready"
                return 0
            fi
        else
            # Without sshpass or expect: check if SSH port is open
            if nc -z -w 2 "$VM_IP" 22 &>/dev/null; then
                echo "  SSH is ready"
                return 0
            fi
        fi
        sleep 2
        count=$((count + 2))
        printf "  Waiting for SSH... (%ds/%ds)\r" "$count" "$max_wait"
    done
    
    echo "  SSH not available after ${max_wait}s"
    return 1
}

# Setup SSH keys
setup_ssh_keys() {
    local vm_ip="$1"
    
    echo "  Checking SSH keys..."
    
    # Check if SSH key exists
    if [ ! -f ~/.ssh/id_rsa.pub ] && [ ! -f ~/.ssh/id_ed25519.pub ]; then
        echo "  No SSH key found. Generating..."
        ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519 -N "" -q
        echo "  SSH key generated"
    fi
    
    # Test if key auth already works
    if ssh -o BatchMode=yes -o ConnectTimeout=2 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${vm_ip}" "echo ok" &>/dev/null; then
        echo "  SSH key authentication already configured"
        return 0
    fi
    
    # Copy SSH key using sshpass for automation (silently)
    echo "  Copying SSH key to VM..."
    
    # Ensure sshpass or expect is available
    if ! command -v sshpass &>/dev/null; then
        brew install esolitos/ipa/sshpass &>/dev/null 2>&1 || \
        brew install hudochenkov/sshpass/sshpass &>/dev/null 2>&1 || true
    fi
    
    # Get public key
    local pubkey
    if [ -f ~/.ssh/id_ed25519.pub ]; then
        pubkey=$(cat ~/.ssh/id_ed25519.pub)
    else
        pubkey=$(cat ~/.ssh/id_rsa.pub)
    fi
    
    if command -v sshpass &>/dev/null; then
        # Use sshpass for automated key copy
        SSHPASS="${VM_PASSWORD}" sshpass -e ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "${VM_USER}@${vm_ip}" \
            "mkdir -p ~/.ssh && echo '$pubkey' >> ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys" &>/dev/null
    elif command -v expect &>/dev/null; then
        # Use expect as fallback (usually pre-installed on macOS)
        expect -c "
            set timeout 30
            spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${VM_USER}@${vm_ip} {mkdir -p ~/.ssh && echo '$pubkey' >> ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys}
            expect {
                \"*assword*\" { send \"${VM_PASSWORD}\r\"; exp_continue }
                eof
            }
        " &>/dev/null
    else
        # Last resort: manual password entry
        echo "  ‚ö†Ô∏è  Automated setup unavailable - password: ${VM_PASSWORD}"
        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "${VM_USER}@${vm_ip}" \
            "mkdir -p ~/.ssh && echo '$pubkey' >> ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys"
    fi
    
    echo "  SSH key copied"
}

# Copy and run vm-setup script
run_vm_setup() {
    local vm_ip="$1"
    
    if [ ! -f "$SCRIPT_DIR/vm-setup.sh" ]; then
        echo "  vm-setup.sh not found at $SCRIPT_DIR/vm-setup.sh"
        return 1
    fi
    
    echo "  Copying vm-setup.sh to VM..."
    scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "$SCRIPT_DIR/vm-setup.sh" "${VM_USER}@${vm_ip}":~/ &>/dev/null
    
    echo "  Running vm-setup.sh..."
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "chmod +x ~/vm-setup.sh && ~/vm-setup.sh"
}

# Unlock keychain for SSH sessions (enables agent authentication)
# Returns 0 even on failure to avoid blocking SSH connection
unlock_keychain() {
    local vm_ip="$1"
    
    echo "  Unlocking keychain for SSH access..."
    if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${vm_ip}" "security unlock-keychain -p '${VM_PASSWORD}' login.keychain 2>/dev/null"; then
        echo "  ‚úì Keychain unlocked"
        return 0
    else
        echo "  ‚ö† Could not unlock keychain (may already be unlocked)"
        return 0
    fi
}

# === INIT MODE ===
do_init() {
    echo ""
    echo "CAL Bootstrap - Initialize"
    echo "==========================="
    echo ""
    
    # Step 1: Create cal-clean from base image
    echo "Step 1: Create $VM_CLEAN"
    if vm_exists "$VM_CLEAN"; then
        echo "  $VM_CLEAN already exists, skipping"
    else
        echo "  Cloning from ghcr.io/cirruslabs/macos-sequoia-base:latest..."
        echo "  (This downloads ~25GB, may take a while)"
        "$TART" clone ghcr.io/cirruslabs/macos-sequoia-base:latest "$VM_CLEAN"
        echo "  Setting VM resources (4 CPU, 8GB RAM, 80GB disk)..."
        "$TART" set "$VM_CLEAN" --cpu 4 --memory 8192 --disk-size 80
        echo "  $VM_CLEAN created"
    fi
    
    # Step 2: Create cal-dev from cal-clean
    echo ""
    echo "Step 2: Create $VM_DEV"
    if vm_exists "$VM_DEV"; then
        echo "  $VM_DEV already exists, skipping"
    else
        echo "  Cloning from $VM_CLEAN..."
        "$TART" clone "$VM_CLEAN" "$VM_DEV"
        echo "  $VM_DEV created"
    fi
    
    # Step 3: Start cal-dev and setup
    echo ""
    echo "Step 3: Setup $VM_DEV"
    if ! start_vm_background "$VM_DEV"; then
        echo "  Failed to start VM"
        exit 1
    fi
    
    # Step 4: Setup SSH keys
    echo ""
    echo "Step 4: Setup SSH keys"
    setup_ssh_keys "$VM_IP"
    
    # Step 5: Run vm-setup
    echo ""
    echo "Step 5: Install tools"
    run_vm_setup "$VM_IP"
    
    # Step 6: Prompt user for manual setup
    echo ""
    echo "============================================"
    echo "Manual setup required in VM"
    echo "============================================"
    echo ""
    echo "Opening tmux session in VM..."
    echo ""
    
    # Create an interactive authentication script on the VM
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "${VM_USER}@${VM_IP}" 'cat > ~/.cal-welcome.sh << '\''WELCOME'\''
#!/bin/zsh

# Initialize environment with all paths
eval "$(/opt/homebrew/bin/brew shellenv)"
export PATH="/Users/admin/.local/bin:/Users/admin/.opencode/bin:/Users/admin/go/bin:/opt/homebrew/bin:$PATH"

clear
echo ""
echo "============================================"
echo "  CAL VM Setup - Authenticate Agents"
echo "============================================"
echo ""
echo "üí° tmux: Ctrl+b d to detach if needed"
echo ""

# GitHub CLI
echo ""
echo -n "Authenticate GitHub CLI? [Y/n] "
read -r -k 1 reply
echo ""
if [[ ! "$reply" =~ ^[Nn]$ ]]; then
    echo "Starting GitHub CLI authentication..."
    echo "----------------------------------------"
    gh auth login
    echo "----------------------------------------"
    echo "‚úì GitHub CLI complete"
fi

# Opencode
echo ""
echo -n "Authenticate Opencode? [Y/n] "
read -r -k 1 reply
echo ""
if [[ ! "$reply" =~ ^[Nn]$ ]]; then
    echo "Starting Opencode authentication..."
    echo "----------------------------------------"
    opencode auth login
    echo "----------------------------------------"
    echo "‚úì Opencode complete"
fi

# Cursor Agent
echo ""
echo -n "Authenticate Cursor Agent? [Y/n] "
read -r -k 1 reply
echo ""
if [[ ! "$reply" =~ ^[Nn]$ ]]; then
    echo "Starting Cursor Agent authentication..."
    echo "----------------------------------------"
    agent
    echo "----------------------------------------"
    echo "‚úì Cursor Agent complete"
fi

# Claude Code (last)
echo ""
echo -n "Authenticate Claude Code? [Y/n] "
read -r -k 1 reply
echo ""
if [[ ! "$reply" =~ ^[Nn]$ ]]; then
    echo "Starting Claude Code..."
    echo "Press Ctrl+C to exit when done."
    echo "----------------------------------------"
    claude
    echo "----------------------------------------"
    echo "‚úì Claude Code complete"
fi

echo ""
echo "============================================"
echo "  ‚úÖ Setup Complete!"
echo "============================================"
echo ""
echo "All authentications done."
echo "Press Ctrl+C or type exit to continue."
echo ""
WELCOME
chmod +x ~/.cal-welcome.sh'

    # Automatically SSH into the VM with tmux and show welcome message
    ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${VM_IP}" "TERM=xterm-256color /opt/homebrew/bin/tmux new-session -A -s setup 'zsh ~/.cal-welcome.sh'"

    echo ""
    echo "Continuing with setup..."
    
    # Step 7: Create cal-initialised
    echo ""
    echo "Step 7: Create $VM_INIT snapshot"
    
    # Stop VM first
    CLEANUP_VM=false
    echo "  Stopping $VM_DEV..."
    "$TART" stop "$VM_DEV" 2>/dev/null || true
    kill "$TART_PID" 2>/dev/null || true
    sleep 2
    
    # Delete existing if present
    if vm_exists "$VM_INIT"; then
        if [ "$SKIP_CONFIRM" = true ]; then
            "$TART" delete "$VM_INIT"
        else
            echo "  $VM_INIT already exists. Replace it? (y/N)"
            read -r -k 1 reply
            echo ""
            if [[ $reply =~ ^[Yy]$ ]]; then
                "$TART" delete "$VM_INIT"
            else
                echo "  Keeping existing $VM_INIT"
                echo ""
                echo "Bootstrap complete!"
                return 0
            fi
        fi
    fi
    
    echo "  Creating $VM_INIT from $VM_DEV..."
    "$TART" clone "$VM_DEV" "$VM_INIT"
    echo "  $VM_INIT created"
    
    echo ""
    echo "Bootstrap complete!"
    echo ""
    echo "VMs created:"
    printf "  %-17s - Base macOS image\n" "$VM_CLEAN"
    printf "  %-17s - Development VM (use this)\n" "$VM_DEV"
    printf "  %-17s - Snapshot with tools configured\n" "$VM_INIT"
    echo ""
    echo "Next: Run './cal-bootstrap --run' to start developing"
}

# === RUN MODE ===
do_run() {
    echo ""
    echo "CAL Bootstrap - Run"
    echo "===================="
    echo ""
    
    local vm_to_run="$VM_DEV"
    
    # Check if VM exists
    if ! vm_exists "$vm_to_run"; then
        echo "$vm_to_run does not exist."
        echo ""
        echo "Run './cal-bootstrap --init' to set up the environment."
        exit 1
    fi
    
    # If already running, just SSH in
    if vm_running "$vm_to_run"; then
        echo "$vm_to_run is already running."
        VM_IP=$("$TART" ip "$vm_to_run" 2>/dev/null || echo "")
        if [ -n "$VM_IP" ]; then
            echo ""
            unlock_keychain "$VM_IP"
            echo ""
            echo "Connecting via SSH with tmux..."
            echo "üí° tmux session 'cal' (Ctrl+b d to detach, Ctrl+b ? for help)"
            echo ""
            ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                "${VM_USER}@${VM_IP}" "TERM=xterm-256color /opt/homebrew/bin/tmux new-session -A -s cal"
        else
            echo "Could not get VM IP address."
            exit 1
        fi
        exit 0
    fi
    
    # Start VM
    if ! start_vm_background "$vm_to_run"; then
        echo "Failed to start VM"
        exit 1
    fi
    
    # Don't cleanup on success
    CLEANUP_VM=false
    
    echo ""
    echo "$vm_to_run is running (PID: $TART_PID)"

    # Unlock keychain for SSH access
    unlock_keychain "$VM_IP"

    echo ""
    echo "VNC:   open vnc://${VM_IP}"
    echo "Stop:  $TART stop $vm_to_run"
    echo ""
    echo "üí° If agent login fails, use Screen Sharing (standard mode, not High Performance):"
    echo "   open vnc://${VM_IP} ‚Üí Authenticate agent ‚Üí Return to terminal"
    echo ""
    echo "Connecting via SSH with tmux..."
    echo "üí° tmux session 'cal' (Ctrl+b d to detach, Ctrl+b ? for help)"
    echo ""
    
    # SSH into the VM with tmux (always)
    ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${VM_IP}" "TERM=xterm-256color /opt/homebrew/bin/tmux new-session -A -s cal"
}

# === STOP MODE ===
do_stop() {
    echo ""
    echo "CAL Bootstrap - Stop"
    echo "===================="
    echo ""

    if ! vm_exists "$VM_DEV"; then
        echo "$VM_DEV does not exist."
        exit 1
    fi

    if ! vm_running "$VM_DEV"; then
        echo "$VM_DEV is not running."
        exit 0
    fi

    echo "Stopping $VM_DEV..."
    "$TART" stop "$VM_DEV"
    echo ""
    echo "$VM_DEV stopped."
}

# === RESTART MODE ===
do_restart() {
    echo ""
    echo "CAL Bootstrap - Restart"
    echo "========================="
    echo ""

    if ! vm_exists "$VM_DEV"; then
        echo "$VM_DEV does not exist."
        echo ""
        echo "Run './cal-bootstrap --init' to set up the environment."
        exit 1
    fi

    # Stop if running
    if vm_running "$VM_DEV"; then
        echo "Stopping $VM_DEV..."
        "$TART" stop "$VM_DEV"
        sleep 2
        echo ""
    fi

    # Start VM
    if ! start_vm_background "$VM_DEV"; then
        echo "Failed to start VM"
        exit 1
    fi

    # Don't cleanup on success
    CLEANUP_VM=false

    echo ""
    echo "$VM_DEV is running (PID: $TART_PID)"

    # Unlock keychain for SSH access
    unlock_keychain "$VM_IP"

    echo ""
    echo "VNC:   open vnc://${VM_IP}"
    echo "Stop:  $TART stop $vm_to_run"
    echo ""
    echo "Connecting via SSH with tmux..."
    echo "üí° tmux session 'cal' (Ctrl+b d to detach, Ctrl+b ? for help)"
    echo ""

    # SSH into the VM with tmux (always)
    ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${VM_IP}" "TERM=xterm-256color /opt/homebrew/bin/tmux new-session -A -s cal"
}

# === SNAPSHOT MODE ===
do_snapshot() {
    local action="$1"
    local name="$2"
    
    echo ""
    echo "CAL Bootstrap - Snapshot"
    echo "========================="
    echo ""
    
    case "$action" in
        create)
            if [ -z "$name" ]; then
                echo "Usage: ./cal-bootstrap --snapshot create <name>"
                exit 1
            fi
            
            # Stop VM if running
            stop_vm "$VM_DEV"
            
            local snapshot_name="${VM_DEV}-${name}"
            
            if vm_exists "$snapshot_name"; then
                if [ "$SKIP_CONFIRM" = true ]; then
                    "$TART" delete "$snapshot_name"
                else
                    echo "Snapshot $snapshot_name already exists. Replace? (y/N)"
                    read -r -k 1 reply
                    echo ""
                    if [[ $reply =~ ^[Yy]$ ]]; then
                        "$TART" delete "$snapshot_name"
                    else
                        echo "Aborted"
                        exit 1
                    fi
                fi
            fi
            
            echo "Creating snapshot: $snapshot_name"
            "$TART" clone "$VM_DEV" "$snapshot_name"
            echo ""
            echo "Snapshot created: $snapshot_name"
            echo ""
            echo "Restore with: ./cal-bootstrap --snapshot restore $name"
            ;;
            
        restore)
            if [ -z "$name" ]; then
                echo "Usage: ./cal-bootstrap --snapshot restore <name>"
                echo ""
                do_snapshot list
                exit 1
            fi

            # Resolve short name to full name
            local restore_from
            restore_from=$(resolve_vm_name "$name")

            if [ -z "$restore_from" ]; then
                # Try with prefix
                restore_from=$(resolve_vm_name "${VM_DEV}-${name}")
            fi

            if [ -z "$restore_from" ]; then
                echo "VM '$name' not found"
                echo ""
                do_snapshot list
                exit 1
            fi

            # Can't restore from cal-dev to cal-dev
            if [ "$restore_from" = "$VM_DEV" ]; then
                echo "Cannot restore $VM_DEV from itself"
                exit 1
            fi

            # Check if cal-dev exists (early exit if missing)
            if ! vm_exists "$VM_DEV"; then
                echo "‚ö†Ô∏è  $VM_DEV does not exist."
                echo ""
                echo "Cannot restore to a non-existent VM."
                echo ""
                echo "You can:"
                echo "  1. Re-run: ./scripts/cal-bootstrap --init"
                echo "  2. Or create manually: tart clone cal-clean $VM_DEV"
                echo ""
                exit 1
            fi

            # Check for git changes if VM is running (don't start VM if it's stopped)
            if vm_running "$VM_DEV"; then
                echo "Checking for git changes in $VM_DEV..."
                local vm_ip
                vm_ip=$("$TART" ip "$VM_DEV" 2>/dev/null || echo "")

                if [ -n "$vm_ip" ]; then
                    local has_uncommitted=false
                    local has_unpushed=false

                    # Check for uncommitted changes
                    local uncommitted_check
                    uncommitted_check=$(ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                        "${VM_USER}@${vm_ip}" 'for gitdir in $(find ~/workspace -name ".git" -type d 2>/dev/null); do dir=$(dirname "$gitdir"); (cd "$dir" 2>/dev/null && [ -n "$(git status --porcelain 2>/dev/null)" ] && echo "$dir"); done' 2>/dev/null || echo "")

                    if [ -n "$uncommitted_check" ]; then
                        has_uncommitted=true
                    fi

                    # Check for unpushed commits (requires upstream tracking to be set)
                    local unpushed_check
                    unpushed_check=$(ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                        "${VM_USER}@${vm_ip}" 'for gitdir in $(find ~/workspace -name ".git" -type d 2>/dev/null); do dir=$(dirname "$gitdir"); (cd "$dir" 2>/dev/null && branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null); if [ "$branch" != "HEAD" ] && git rev-parse "$branch@{u}" >/dev/null 2>&1 && [ -n "$(git log "@{u}.." --oneline 2>/dev/null)" ]; then echo "$dir"; fi); done' 2>/dev/null || echo "")

                    if [ -n "$unpushed_check" ]; then
                        has_unpushed=true
                    fi

                    # Show warnings
                    if [ "$has_uncommitted" = true ] || [ "$has_unpushed" = true ]; then
                        echo ""
                        echo "‚ö†Ô∏è  WARNING: Found git changes that will be lost!"
                        echo ""

                        if [ "$has_uncommitted" = true ]; then
                            echo "Uncommitted changes in:"
                            echo "$uncommitted_check" | while read -r repo; do
                                [ -n "$repo" ] && echo "  - $repo"
                            done
                            echo ""
                        fi

                        if [ "$has_unpushed" = true ]; then
                            echo "Unpushed commits in:"
                            echo "$unpushed_check" | while read -r repo; do
                                [ -n "$repo" ] && echo "  - $repo"
                            done
                            echo ""
                        fi

                        echo "These changes will be lost if you restore from snapshot."
                    else
                        echo "  ‚úì No uncommitted or unpushed changes found"
                    fi
                fi
            fi

            # Confirm (after git check, once)
            if [ "$SKIP_CONFIRM" = false ]; then
                echo ""
                echo "This will replace $VM_DEV with $restore_from"
                echo "All changes in $VM_DEV will be lost!"
                echo ""
                echo "Continue? (y/N)"
                read -r -k 1 reply
                echo ""
                if [[ ! $reply =~ ^[Yy]$ ]]; then
                    echo "Aborted"
                    exit 1
                fi
            fi

            # Check for git changes if VM is running
            if vm_running "$VM_DEV"; then
                echo "Checking for git changes in $VM_DEV..."
                local vm_ip
                vm_ip=$("$TART" ip "$VM_DEV" 2>/dev/null || echo "")

                if [ -n "$vm_ip" ]; then
                    local has_uncommitted=false
                    local has_unpushed=false

                    # Check for uncommitted changes (more reliable approach)
                    local uncommitted_check
                    uncommitted_check=$(ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                        "${VM_USER}@${vm_ip}" 'for gitdir in $(find ~/workspace -name ".git" -type d 2>/dev/null); do dir=$(dirname "$gitdir"); (cd "$dir" 2>/dev/null && [ -n "$(git status --porcelain 2>/dev/null)" ] && echo "$dir"); done' 2>/dev/null || echo "")

                    if [ -n "$uncommitted_check" ]; then
                        has_uncommitted=true
                    fi

                    # Check for unpushed commits (requires upstream tracking to be set)
                    local unpushed_check
                    unpushed_check=$(ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                        "${VM_USER}@${vm_ip}" 'for gitdir in $(find ~/workspace -name ".git" -type d 2>/dev/null); do dir=$(dirname "$gitdir"); (cd "$dir" 2>/dev/null && branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null); if [ "$branch" != "HEAD" ] && git rev-parse "$branch@{u}" >/dev/null 2>&1 && [ -n "$(git log "@{u}.." --oneline 2>/dev/null)" ]; then echo "$dir"; fi); done' 2>/dev/null || echo "")

                    if [ -n "$unpushed_check" ]; then
                        has_unpushed=true
                    fi

                    # Show warnings
                    if [ "$has_uncommitted" = true ] || [ "$has_unpushed" = true ]; then
                        echo ""
                        echo "‚ö†Ô∏è  WARNING: Found git changes that will be lost!"
                        echo ""

                        if [ "$has_uncommitted" = true ]; then
                            echo "Uncommitted changes in:"
                            echo "$uncommitted_check" | while read -r repo; do
                                [ -n "$repo" ] && echo "  - $repo"
                            done
                            echo ""
                        fi

                        if [ "$has_unpushed" = true ]; then
                            echo "Unpushed commits in:"
                            echo "$unpushed_check" | while read -r repo; do
                                [ -n "$repo" ] && echo "  - $repo"
                            done
                            echo ""
                        fi

                        echo "These changes will be lost if you restore from snapshot."
                        echo ""
                        if [ "$SKIP_CONFIRM" = false ]; then
                            echo "Continue anyway? (y/N)"
                            read -r -k 1 reply
                            echo ""
                            if [[ ! $reply =~ ^[Yy]$ ]]; then
                                echo "Aborted"
                                exit 1
                            fi
                        fi
                    else
                        echo "  ‚úì No uncommitted or unpushed changes found"
                    fi
                fi
            fi

            # Confirm (before git check so we don't start VM unnecessarily)
            if [ "$SKIP_CONFIRM" = false ]; then
                echo "This will replace $VM_DEV with $restore_from"
                echo "All changes in $VM_DEV will be lost!"
                echo ""
                echo "Continue? (y/N)"
                read -r -k 1 reply
                echo ""
                if [[ ! $reply =~ ^[Yy]$ ]]; then
                    echo "Aborted"
                    exit 1
                fi
            fi

            # Check for git changes (start VM briefly if stopped)
            local vm_was_running=false
            if vm_running "$VM_DEV"; then
                vm_was_running=true
            else
                # Start VM briefly to check git changes
                echo "Checking for git changes in $VM_DEV..."
                if ! start_vm_background "$VM_DEV"; then
                    echo "  ‚ö† Could not start VM to check for git changes"
                    echo "  Proceeding with restore without git check..."
                else
                    vm_was_running=false  # Wasn't running, we started it
                fi
            fi

            # Now check for git changes (VM is running)
            if vm_running "$VM_DEV"; then
                local vm_ip
                vm_ip=$("$TART" ip "$VM_DEV" 2>/dev/null || echo "")

                if [ -n "$vm_ip" ]; then
                    local has_uncommitted=false
                    local has_unpushed=false

                    # Check for uncommitted changes
                    local uncommitted_check
                    uncommitted_check=$(ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                        "${VM_USER}@${vm_ip}" 'for gitdir in $(find ~/workspace -name ".git" -type d 2>/dev/null); do dir=$(dirname "$gitdir"); (cd "$dir" 2>/dev/null && [ -n "$(git status --porcelain 2>/dev/null)" ] && echo "$dir"); done' 2>/dev/null || echo "")

                    if [ -n "$uncommitted_check" ]; then
                        has_uncommitted=true
                    fi

                    # Check for unpushed commits (requires upstream tracking to be set)
                    local unpushed_check
                    unpushed_check=$(ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                        "${VM_USER}@${vm_ip}" 'for gitdir in $(find ~/workspace -name ".git" -type d 2>/dev/null); do dir=$(dirname "$gitdir"); (cd "$dir" 2>/dev/null && branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null); if [ "$branch" != "HEAD" ] && git rev-parse "$branch@{u}" >/dev/null 2>&1 && [ -n "$(git log "@{u}.." --oneline 2>/dev/null)" ]; then echo "$dir"; fi); done' 2>/dev/null || echo "")

                    if [ -n "$unpushed_check" ]; then
                        has_unpushed=true
                    fi

                    # Show warnings
                    if [ "$has_uncommitted" = true ] || [ "$has_unpushed" = true ]; then
                        echo ""
                        echo "‚ö†Ô∏è  WARNING: Found git changes that will be lost!"
                        echo ""

                        if [ "$has_uncommitted" = true ]; then
                            echo "Uncommitted changes in:"
                            echo "$uncommitted_check" | while read -r repo; do
                                [ -n "$repo" ] && echo "  - $repo"
                            done
                            echo ""
                        fi

                        if [ "$has_unpushed" = true ]; then
                            echo "Unpushed commits in:"
                            echo "$unpushed_check" | while read -r repo; do
                                [ -n "$repo" ] && echo "  - $repo"
                            done
                            echo ""
                        fi

                        echo "These changes will be lost if you restore from snapshot."
                        echo ""
                        if [ "$SKIP_CONFIRM" = false ]; then
                            echo "Continue anyway? (y/N)"
                            read -r -k 1 reply
                            echo ""
                            if [[ ! $reply =~ ^[Yy]$ ]]; then
                                echo "Aborted"
                                exit 1
                            fi
                        fi
                    else
                        echo "  ‚úì No uncommitted or unpushed changes found"
                    fi
                fi

                # Stop VM if we started it for git check
                if [ "$vm_was_running" = false ]; then
                    echo ""
                    stop_vm "$VM_DEV"
                fi
            fi
            
            # Stop and delete current VM
            stop_vm "$VM_DEV"

            # Delete VM
            if vm_exists "$VM_DEV"; then
                echo "Deleting $VM_DEV..."
                if ! "$TART" delete "$VM_DEV"; then
                    echo ""
                    echo "‚ö†Ô∏è  Failed to delete $VM_DEV"
                    echo ""
                    echo "This can happen if:"
                    echo "  ‚Ä¢ VM is in an inconsistent state"
                    echo "  ‚Ä¢ Tart is holding a lock on the VM"
                    echo "  ‚Ä¢ Another process is using the VM"
                    echo ""
                    echo "You may need to delete it manually:"
                    echo "  tart delete $VM_DEV"
                    echo ""
                    echo "Or restart your machine if Tart is locked."
                    echo ""
                    echo "Aborting restore."
                    exit 1
                fi
            fi

            # Restore from snapshot
            echo "Restoring from $restore_from..."
            "$TART" clone "$restore_from" "$VM_DEV"
            
            echo ""
            echo "Restored $VM_DEV from $restore_from"
            echo ""
            
            # Give different instructions based on what was restored
            if [ "$restore_from" = "$VM_CLEAN" ]; then
                echo "‚ö†Ô∏è  Restored from clean base image (no tools installed)"
                echo ""
                echo "Run './cal-bootstrap --init' to set up tools and agents"
            else
                echo "Run './cal-bootstrap --run' to start the VM"
            fi
            ;;
            
        list)
            # Check for short name collisions
            local collision_check
            collision_check=$("$TART" list | awk 'NR==1 {next} {
                full_name = $2
                source = $1

                # Create short name
                short_name = full_name
                if (source == "OCI") {
                    gsub(/ghcr.io\/cirruslabs\/macos-/, "", short_name)
                    if (match(short_name, /@sha256:/)) {
                        short_name = substr(short_name, 1, RSTART-1) "-digest"
                    }
                }

                print short_name
            }' | sort | uniq -d)

            if [ -n "$collision_check" ]; then
                echo "‚ö†Ô∏è  WARNING: Short name collisions detected!"
                echo "   Use full names for these VMs:"
                echo ""
            fi

            # List VMs (simplified output - show all VMs/snapshots together)
            "$TART" list | awk -v collisions="$collision_check" '
                BEGIN {
                    # Build collision map
                    split(collisions, coll_array, "\n")
                    for (i in coll_array) {
                        collision_map[coll_array[i]] = 1
                    }
                }
                NR==1 {next}
                {
                    full_name = $2
                    source = $1
                    state = $NF

                    # Create short name for display
                    short_name = full_name
                    if (source == "OCI") {
                        gsub(/ghcr.io\/cirruslabs\/macos-/, "", short_name)
                        if (match(short_name, /@sha256:/)) {
                            short_name = substr(short_name, 1, RSTART-1) "-digest"
                        }
                    }

                    # Show full name if collision
                    if (short_name in collision_map) {
                        printf "  %s (%s)\n", full_name, state
                    } else {
                        printf "  %s (%s)\n", short_name, state
                    }
                }'
            echo ""
            echo "üí° All VMs and snapshots are listed. Use short names unless collision detected."
            echo ""
            exit 0
            ;;
            
        delete)
            if [ -z "$name" ]; then
                echo "Usage: ./cal-bootstrap --snapshot delete <name>"
                echo ""
                do_snapshot list
                exit 1
            fi
            
            # Resolve short name to full name
            local vm_to_delete
            vm_to_delete=$(resolve_vm_name "$name")
            
            if [ -z "$vm_to_delete" ]; then
                # Try with prefix
                vm_to_delete=$(resolve_vm_name "${VM_DEV}-${name}")
            fi
            
            if [ -z "$vm_to_delete" ]; then
                echo "VM '$name' not found"
                echo ""
                do_snapshot list
                exit 1
            fi
            
            # Stop if running
            stop_vm "$vm_to_delete"
            
            # Confirm (with extra warning for cal-dev)
            if [ "$SKIP_CONFIRM" = false ]; then
                if [ "$vm_to_delete" = "$VM_DEV" ]; then
                    echo "‚ö†Ô∏è  WARNING: Deleting your working VM!"
                    echo ""
                    echo "This will delete $vm_to_delete permanently."
                    echo "You may want to use restore instead to reset state."
                    echo ""
                fi
                echo "Delete $vm_to_delete?"
                echo ""
                echo "Continue? (y/N)"
                read -r -k 1 reply
                echo ""
                if [[ ! $reply =~ ^[Yy]$ ]]; then
                    echo "Aborted"
                    exit 1
                fi
            fi
            
            echo "Deleting $vm_to_delete..."
            "$TART" delete "$vm_to_delete"
            echo ""
            echo "Deleted: $vm_to_delete"
            ;;
            
        *)
            echo "Usage: ./cal-bootstrap --snapshot <list|create|restore|delete> [name]"
            echo ""
            echo "Examples:"
            echo "  ./cal-bootstrap --snapshot list"
            echo "  ./cal-bootstrap --snapshot create before-refactor"
            echo "  ./cal-bootstrap --snapshot restore before-refactor"
            echo "  ./cal-bootstrap --snapshot delete before-refactor"
            exit 1
            ;;
    esac
}

# === MAIN ===

# Parse arguments
MODE=""
SKIP_CONFIRM=false
SNAPSHOT_ACTION=""
SNAPSHOT_NAME=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --init|-i)
            MODE="init"
            shift
            ;;
        --run)
            MODE="run"
            shift
            ;;
        --restart)
            MODE="restart"
            shift
            ;;
        --stop|-s)
            MODE="stop"
            shift
            ;;
        --snapshot|-S)
            MODE="snapshot"
            shift
            SNAPSHOT_ACTION="${1:-}"
            shift || true
            SNAPSHOT_NAME="${1:-}"
            shift || true
            ;;
        --yes|-y)
            SKIP_CONFIRM=true
            shift
            ;;
        --help|-h)
            echo "CAL Bootstrap - VM Environment Setup"
            echo ""
            echo "Usage: ./cal-bootstrap [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --init, -i                    Initialize VM environment"
            echo "  --run                         Run cal-dev with tmux (default if VMs exist)"
            echo "  --restart                     Restart cal-dev and connect with tmux"
            echo "  --stop, -s                    Stop cal-dev"
            echo "  --snapshot, -S list           List available snapshots"
            echo "  --snapshot, -S create <name>  Create a named snapshot"
            echo "  --snapshot, -S restore <name> Restore from a snapshot"
            echo "  --snapshot, -S delete <name>  Delete a snapshot"
            echo "  --yes, -y                     Skip confirmation prompts"
            echo "  --help, -h                    Show this help"
            echo ""
            echo "Examples:"
            echo "  ./cal-bootstrap --init              # First-time setup"
            echo "  ./cal-bootstrap                     # Start cal-dev (auto-detects mode)"
            echo "  ./cal-bootstrap --restart           # Restart cal-dev and connect"
            echo "  ./cal-bootstrap --snapshot create pre-experiment"
            echo "  ./cal-bootstrap --snapshot restore pre-experiment"
            echo "  ./cal-bootstrap --snapshot delete pre-experiment"
            echo ""
            echo "Note: tmux is always used for persistent sessions."
            echo "      Ctrl+b d to detach, Ctrl+b ? for help"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Run './cal-bootstrap --help' for usage"
            exit 1
            ;;
    esac
done

# Find tart
TART=$(find_tart)
if [ -z "$TART" ]; then
    echo "Error: tart not found"
    echo ""
    echo "Install with: brew install cirruslabs/cli/tart"
    echo ""
    echo "Or set TART_PATH environment variable"
    exit 1
fi

# Auto-detect mode if not specified
if [ -z "$MODE" ]; then
    if vm_exists "$VM_CLEAN" && vm_exists "$VM_DEV" && vm_exists "$VM_INIT"; then
        MODE="run"
    else
        MODE="init"
    fi
    echo "Auto-detected mode: $MODE"
fi

# Execute mode
case "$MODE" in
    init)
        do_init
        ;;
    run)
        do_run
        ;;
    restart)
        do_restart
        ;;
    stop)
        do_stop
        ;;
    snapshot)
        do_snapshot "$SNAPSHOT_ACTION" "$SNAPSHOT_NAME"
        ;;
esac
