#!/bin/zsh

set -e

# Get script directory (works in zsh)
SCRIPT_DIR="${0:A:h}"

# CAL Bootstrap Script
# Usage: ./cal-bootstrap [--init|-i] [--run] [--restart|-r] [--stop] [--snapshot <action> <name>]
#
# Options:
#   --init, -i      Initialize VM environment (create cal-clean, cal-dev, cal-init)
#   --run           Run cal-dev and SSH in with tmux (default if VMs exist)
#   --restart, -r   Restart cal-dev and SSH in with tmux
#   --stop, -s      Stop cal-dev
#   --snapshot, -S  Manage snapshots (list, create, restore, delete)
#   --yes, -y       Skip confirmation prompts
#
# Environment variables:
#   TART_PATH       - Path to tart binary
#   VM_USER         - VM username (default: admin)
#   VM_PASSWORD     - VM password (default: admin)

# VM names
VM_CLEAN="cal-clean"
VM_DEV="cal-dev"
VM_INIT="cal-init"

# VM credentials
VM_USER="${VM_USER:-admin}"
VM_PASSWORD="${VM_PASSWORD:-admin}"

# Host user for transparent proxy tunnel (the user running this script)
HOST_USER="${HOST_USER:-$(whoami)}"

# Transparent proxy settings (configurable via environment)
# Uses sshuttle for truly transparent network routing - no app configuration needed
PROXY_MODE="${PROXY_MODE:-auto}"  # on, off, or auto (default)
HOST_GATEWAY="${HOST_GATEWAY:-192.168.64.1}"

# Log file for debugging
CAL_LOG="${HOME}/.cal-bootstrap.log"

# Cleanup tracking
CLEANUP_VM=false
CLEANUP_DONE=false
TART_PID=""

# Cleanup function
cleanup() {
    if [ "$CLEANUP_DONE" = true ]; then
        return
    fi
    CLEANUP_DONE=true
    
    if [ "$CLEANUP_VM" = true ] && [ -n "$TART_PID" ] && kill -0 "$TART_PID" 2>/dev/null; then
        echo ""
        echo "Cleaning up background VM process (PID: $TART_PID)..."
        kill "$TART_PID" 2>/dev/null || true
        wait "$TART_PID" 2>/dev/null || true
    fi
}

# Handle Ctrl-C properly
handle_interrupt() {
    echo ""
    echo "Interrupted by user"
    cleanup
    exit 130
}

trap cleanup EXIT
trap handle_interrupt INT TERM

# Find tart binary
find_tart() {
    if command -v tart &>/dev/null; then
        echo "tart"
    elif [ -n "$TART_PATH" ] && [ -x "$TART_PATH" ]; then
        echo "$TART_PATH"
    elif [ -x "./tart.app/Contents/MacOS/tart" ]; then
        echo "./tart.app/Contents/MacOS/tart"
    else
        echo ""
    fi
}

# Check if VM exists
vm_exists() {
    "$TART" list 2>/dev/null | awk -v vm="$1" 'NR>1 { if ($2 == vm) { found=1; exit } } END { if (found) exit 0; else exit 1 }'
}

# Resolve VM name (short name to full name if needed)
resolve_vm_name() {
    local input_name="$1"
    
    # If VM exists with exact name, use it
    if vm_exists "$input_name"; then
        echo "$input_name"
        return 0
    fi
    
    # Try to find by short name pattern
    local matches
    matches=$("$TART" list 2>/dev/null | awk -v short="$input_name" '
        NR==1 {next}
        {
            full_name = $2
            source = $1
            
            # Create short name
            short_name = full_name
            if (source == "OCI") {
                gsub(/ghcr.io\/cirruslabs\/macos-/, "", short_name)
                if (match(short_name, /@sha256:/)) {
                    short_name = substr(short_name, 1, RSTART-1) "-digest"
                }
            }
            
            # Match short name
            if (short_name == short) {
                print full_name
            }
        }
    ')
    
    # Check for multiple matches (collision)
    local match_count
    match_count=$(echo "$matches" | grep -c '^' 2>/dev/null || echo 0)
    
    if [ "$match_count" -gt 1 ]; then
        echo "Error: Short name '$input_name' matches multiple VMs:" >&2
        echo "$matches" | sed 's/^/  - /' >&2
        echo "" >&2
        echo "Use full name instead." >&2
        return 2
    elif [ "$match_count" -eq 1 ]; then
        echo "$matches"
        return 0
    fi
    
    # Not found
    return 1
}

# Check if VM is running
vm_running() {
    "$TART" list 2>/dev/null | awk -v vm="$1" 'NR>1 { if ($2 == vm && $NF == "running") { found=1; exit } } END { if (found) exit 0; else exit 1 }'
}

# Stop VM if running
stop_vm() {
    local vm="$1"
    if vm_running "$vm"; then
        echo "  Stopping $vm..."
        "$TART" stop "$vm" 2>/dev/null || true
        sleep 2
    fi
}

# Start VM in background and wait for IP/SSH
start_vm_background() {
    local vm="$1"
    
    echo "  Starting $vm in background..."
    "$TART" run --no-graphics "$vm" >/dev/null 2>&1 &
    TART_PID=$!
    disown "$TART_PID" 2>/dev/null || true
    CLEANUP_VM=true
    echo "  VM started (PID: $TART_PID)"
    
    # Wait for IP
    echo "  Waiting for IP..."
    local max_wait=60
    local count=0
    VM_IP=""
    
    while [ $count -lt $max_wait ]; do
        sleep 2
        count=$((count + 2))
        VM_IP=$("$TART" ip "$vm" 2>/dev/null || echo "")
        if [ -n "$VM_IP" ]; then
            echo "  VM IP: $VM_IP"
            break
        fi
        printf "  Waiting... (%ds/%ds)\r" "$count" "$max_wait"
    done
    
    if [ -z "$VM_IP" ]; then
        echo "  Could not obtain IP after ${max_wait}s"
        return 1
    fi
    
    # Wait for SSH
    echo "  Waiting for SSH..."
    
    # Ensure sshpass is available for automated setup (install quietly if needed)
    if ! command -v sshpass &>/dev/null; then
        # Try to install sshpass silently
        brew install esolitos/ipa/sshpass &>/dev/null 2>&1 || \
        brew install hudochenkov/sshpass/sshpass &>/dev/null 2>&1 || true
    fi
    
    local has_sshpass=false
    local has_expect=false
    if command -v sshpass &>/dev/null; then
        has_sshpass=true
    elif command -v expect &>/dev/null; then
        has_expect=true
    fi
    
    count=0
    
    while [ $count -lt $max_wait ]; do
        if [ "$has_sshpass" = true ]; then
            # With sshpass: try automated password auth
            if SSHPASS="${VM_PASSWORD}" sshpass -e ssh -o ConnectTimeout=2 -o StrictHostKeyChecking=no \
                   -o UserKnownHostsFile=/dev/null -o PreferredAuthentications=password \
                   "${VM_USER}@${VM_IP}" "echo ok" &>/dev/null 2>&1; then
                echo "  SSH is ready"
                return 0
            fi
        elif [ "$has_expect" = true ]; then
            # With expect: try automated password auth
            if expect -c "
                set timeout 5
                spawn ssh -o ConnectTimeout=2 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${VM_USER}@${VM_IP} echo ok
                expect {
                    \"*assword*\" { send \"${VM_PASSWORD}\r\"; exp_continue }
                    \"ok\" { exit 0 }
                    timeout { exit 1 }
                    eof { exit 1 }
                }
            " &>/dev/null 2>&1; then
                echo "  SSH is ready"
                return 0
            fi
        else
            # Without sshpass or expect: check if SSH port is open
            if nc -z -w 2 "$VM_IP" 22 &>/dev/null; then
                echo "  SSH is ready"
                return 0
            fi
        fi
        sleep 2
        count=$((count + 2))
        printf "  Waiting for SSH... (%ds/%ds)\r" "$count" "$max_wait"
    done
    
    echo "  SSH not available after ${max_wait}s"
    return 1
}

# Setup SSH keys
setup_ssh_keys() {
    local vm_ip="$1"
    
    echo "  Checking SSH keys..."
    
    # Check if SSH key exists
    if [ ! -f ~/.ssh/id_rsa.pub ] && [ ! -f ~/.ssh/id_ed25519.pub ]; then
        echo "  No SSH key found. Generating..."
        ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519 -N "" -q
        echo "  SSH key generated"
    fi
    
    # Test if key auth already works
    if ssh -o BatchMode=yes -o ConnectTimeout=2 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${vm_ip}" "echo ok" &>/dev/null; then
        echo "  SSH key authentication already configured"
        return 0
    fi
    
    # Copy SSH key using sshpass for automation (silently)
    echo "  Copying SSH key to VM..."
    
    # Ensure sshpass or expect is available
    if ! command -v sshpass &>/dev/null; then
        brew install esolitos/ipa/sshpass &>/dev/null 2>&1 || \
        brew install hudochenkov/sshpass/sshpass &>/dev/null 2>&1 || true
    fi
    
    # Get public key
    local pubkey
    if [ -f ~/.ssh/id_ed25519.pub ]; then
        pubkey=$(cat ~/.ssh/id_ed25519.pub)
    else
        pubkey=$(cat ~/.ssh/id_rsa.pub)
    fi
    
    if command -v sshpass &>/dev/null; then
        # Use sshpass for automated key copy
        SSHPASS="${VM_PASSWORD}" sshpass -e ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "${VM_USER}@${vm_ip}" \
            "mkdir -p ~/.ssh && echo '$pubkey' >> ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys" &>/dev/null
    elif command -v expect &>/dev/null; then
        # Use expect as fallback (usually pre-installed on macOS)
        expect -c "
            set timeout 30
            spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${VM_USER}@${vm_ip} {mkdir -p ~/.ssh && echo '$pubkey' >> ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys}
            expect {
                \"*assword*\" { send \"${VM_PASSWORD}\r\"; exp_continue }
                eof
            }
        " &>/dev/null
    else
        # Last resort: manual password entry
        echo "  âš ï¸  Automated setup unavailable - password: ${VM_PASSWORD}"
        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "${VM_USER}@${vm_ip}" \
            "mkdir -p ~/.ssh && echo '$pubkey' >> ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys"
    fi
    
    echo "  SSH key copied"
}

# Start bootstrap SOCKS proxy (SSH -D tunnel, no extra packages needed)
# Used during --init before sshuttle is installed
start_bootstrap_proxy() {
    local vm_ip="$1"

    echo "  Starting bootstrap SOCKS proxy (SSH tunnel)..."

    # Check if host SSH is available
    if ! check_host_ssh; then
        echo "  âš  Cannot start bootstrap proxy (host SSH not available)"
        return 1
    fi

    # Start SSH SOCKS tunnel from VM to Host
    # -D 1080: SOCKS proxy on localhost:1080
    # -f: background
    # -N: no command
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "ssh -D 1080 -f -N -o StrictHostKeyChecking=yes -o ServerAliveInterval=60 ${HOST_USER}@${HOST_GATEWAY}" 2>> "$CAL_LOG"

    # Wait for tunnel to start
    sleep 2

    # Verify tunnel is running
    local tunnel_running
    tunnel_running=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "nc -z localhost 1080 && echo yes || echo no" 2>> "$CAL_LOG")

    if [ "$tunnel_running" = "yes" ]; then
        echo "  âœ“ Bootstrap SOCKS proxy started (localhost:1080)"
        return 0
    else
        echo "  âš  Bootstrap proxy may not have started"
        return 1
    fi
}

# Stop bootstrap SOCKS proxy
stop_bootstrap_proxy() {
    local vm_ip="$1"

    echo "  Stopping bootstrap SOCKS proxy..."

    # Find and kill the SSH tunnel process
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "pkill -f 'ssh -D 1080' 2>/dev/null || true" 2>> "$CAL_LOG"

    echo "  âœ“ Bootstrap proxy stopped"
}

# Detect host keyboard layout
# Outputs ONLY the layout name to stdout (for capture)
# Status messages go to stderr (for user visibility)
detect_host_keyboard_layout() {
    local plist_path="$HOME/Library/Preferences/com.apple.HIToolbox.plist"

    # Check if preferences file exists
    if [ ! -f "$plist_path" ]; then
        return 1
    fi

    # Try using PlistBuddy (built into macOS) for reliable parsing
    # macOS uses either AppleSelectedInputSources or AppleEnabledInputSources
    local array_key="AppleSelectedInputSources"

    # Check if AppleSelectedInputSources exists, if not try AppleEnabledInputSources
    if ! /usr/libexec/PlistBuddy -c "Print :$array_key" "$plist_path" >/dev/null 2>&1; then
        array_key="AppleEnabledInputSources"
    fi

    # Look through the input sources array for keyboard layout
    local i=0
    local layout=""

    while [ $i -lt 20 ]; do
        # Try to read the input source at index i
        local source_kind
        source_kind=$(/usr/libexec/PlistBuddy -c "Print :$array_key:$i:InputSourceKind" "$plist_path" 2>/dev/null)

        # If we can't read this index, we've reached the end
        if [ -z "$source_kind" ]; then
            break
        fi

        # Check if this is a keyboard layout source
        # Note: InputSourceKind can be "Keyboard Layout" or "Keyboard Layout Source"
        if [[ "$source_kind" == *"Keyboard Layout"* ]]; then
            # Try to get the layout name (note: key has space, must be quoted)
            layout=$(/usr/libexec/PlistBuddy -c "Print :$array_key:$i:'KeyboardLayout Name'" "$plist_path" 2>/dev/null)

            # If no name, try to get the layout ID
            if [ -z "$layout" ]; then
                layout=$(/usr/libexec/PlistBuddy -c "Print :$array_key:$i:'KeyboardLayout ID'" "$plist_path" 2>/dev/null)
            fi

            # If we found a layout, use it and stop
            if [ -n "$layout" ]; then
                break
            fi
        fi

        i=$((i + 1))
    done

    # Output ONLY the layout to stdout (nothing else)
    if [ -n "$layout" ]; then
        echo "$layout"
        return 0
    else
        return 1
    fi
}

# Run vm-setup script from ~/scripts folder
run_vm_setup() {
    local vm_ip="$1"
    local use_proxy="${2:-false}"

    echo "  Running ~/scripts/vm-setup.sh..."

    # Detect host keyboard layout (ignore errors - non-critical feature)
    echo "  Detecting host keyboard layout..."
    local host_layout
    # Get only the LAST line of output (in case of debug pollution)
    host_layout=$(detect_host_keyboard_layout 2>/dev/null | tail -1 | tr -d '\n\r' | xargs) || true

    # Display status
    if [ -n "$host_layout" ]; then
        echo "  âœ“ Detected: $host_layout"
    else
        echo "  âš  Could not detect keyboard layout (skipping)"
    fi

    # Build environment variables
    local env_vars="HOST_USER='${HOST_USER}' PROXY_MODE='${PROXY_MODE}' HOST_GATEWAY='${HOST_GATEWAY}' CAL_VM_NAME='${VM_DEV}' VM_PASSWORD='${VM_PASSWORD}'"

    # Add keyboard layout if detected
    if [ -n "$host_layout" ]; then
        env_vars="${env_vars} HOST_KEYBOARD_LAYOUT='${host_layout}'"
    fi

    # If using proxy during init (bootstrap SOCKS), set proxy env vars
    # socks5h:// tells curl to resolve DNS through the proxy too
    if [ "$use_proxy" = "true" ]; then
        env_vars="${env_vars} ALL_PROXY='socks5h://localhost:1080' http_proxy='socks5h://localhost:1080' https_proxy='socks5h://localhost:1080'"
    fi

    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "${env_vars} ~/scripts/vm-setup.sh"
}

# Setup scripts folder in VM with helper scripts
setup_scripts_folder() {
    local vm_ip="$1"

    echo "  Creating ~/scripts directory in VM..."
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "mkdir -p ~/scripts" 2>> "$CAL_LOG"

    echo "  Copying scripts to ~/scripts..."

    # Copy vm-setup.sh
    if [ -f "$SCRIPT_DIR/vm-setup.sh" ]; then
        scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "$SCRIPT_DIR/vm-setup.sh" "${VM_USER}@${vm_ip}":~/scripts/ 2>> "$CAL_LOG"
        echo "    âœ“ vm-setup.sh"
    else
        echo "    âš  vm-setup.sh not found"
    fi

    # Copy vm-auth.sh
    if [ -f "$SCRIPT_DIR/vm-auth.sh" ]; then
        scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "$SCRIPT_DIR/vm-auth.sh" "${VM_USER}@${vm_ip}":~/scripts/ 2>> "$CAL_LOG"
        echo "    âœ“ vm-auth.sh"
    else
        echo "    âš  vm-auth.sh not found"
    fi

    # Make scripts executable
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "chmod +x ~/scripts/*.sh" 2>> "$CAL_LOG"

    # Add ~/scripts to PATH in .zshrc if not already present
    echo "  Adding ~/scripts to PATH in .zshrc..."
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "if ! grep -q 'export PATH=\"\$HOME/scripts:\$PATH\"' ~/.zshrc; then echo 'export PATH=\"\$HOME/scripts:\$PATH\"' >> ~/.zshrc; echo '    âœ“ Added to PATH'; else echo '    âœ“ Already in PATH'; fi" 2>> "$CAL_LOG"

    echo "  âœ“ Scripts folder configured"
}

# Unlock keychain for SSH sessions (enables agent authentication)
# Returns 0 even on failure to avoid blocking SSH connection
unlock_keychain() {
    local vm_ip="$1"

    echo "  Unlocking keychain for SSH access..."
    if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${vm_ip}" "security unlock-keychain -p '${VM_PASSWORD}' login.keychain 2>/dev/null"; then
        echo "  âœ“ Keychain unlocked"
        return 0
    else
        echo "  âš  Could not unlock keychain (may already be unlocked)"
        return 0
    fi
}

# NOTE: SSH commands throughout this file use similar patterns
# TODO: Future refactoring opportunity - create ssh_to_vm() helper function
# to reduce duplication of: -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null
# However, this would trade off code clarity for DRYness - evaluate trade-offs

# Check VM for uncommitted or unpushed git changes
# Always returns 0 (success) unless critical failure
# Outputs warnings to stdout, sets global variables:
#   - has_uncommitted, has_unpushed (true/false)
#   - uncommitted_check, unpushed_check (repo paths with changes)
check_vm_git_changes() {
    local vm_name="$1"
    local vm_ip="$2"

    has_uncommitted=false
    has_unpushed=false
    uncommitted_check=""
    unpushed_check=""

    if [ -z "$vm_ip" ]; then
        echo "  âš  No VM IP provided for git check"
        return 0  # Non-fatal, allow script to continue
    fi

    echo "Checking for git changes in $vm_name..."

    # Check for uncommitted changes (search common dev directories + home with depth limit)
    uncommitted_check=$(ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" 'for gitdir in $(find ~/workspace ~/projects ~/repos ~/code 2>/dev/null -name ".git" -type d 2>/dev/null; find ~ -maxdepth 2 -name ".git" -type d 2>/dev/null | sort -u); do dir=$(dirname "$gitdir"); (cd "$dir" 2>/dev/null && [ -n "$(git status --porcelain 2>/dev/null)" ] && echo "$dir"); done' 2>/dev/null || echo "")

    if [ -n "$uncommitted_check" ]; then
        has_uncommitted=true
    fi

    # Check for unpushed commits (requires upstream tracking to be set)
    unpushed_check=$(ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" 'for gitdir in $(find ~/workspace ~/projects ~/repos ~/code 2>/dev/null -name ".git" -type d 2>/dev/null; find ~ -maxdepth 2 -name ".git" -type d 2>/dev/null | sort -u); do dir=$(dirname "$gitdir"); (cd "$dir" 2>/dev/null && branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null); if [ "$branch" != "HEAD" ] && git rev-parse "$branch@{u}" >/dev/null 2>&1 && [ -n "$(git log "@{u}.." --oneline 2>/dev/null)" ]; then echo "$dir"; fi); done' 2>/dev/null || echo "")

    if [ -n "$unpushed_check" ]; then
        has_unpushed=true
    fi

    # Show warnings
    if [ "$has_uncommitted" = true ] || [ "$has_unpushed" = true ]; then
        echo ""
        echo "âš ï¸  WARNING: Found git changes that will be lost!"
        echo ""

        if [ "$has_uncommitted" = true ]; then
            echo "Uncommitted changes in:"
            echo "$uncommitted_check" | while read -r repo; do
                [ -n "$repo" ] && echo "  - $repo"
            done
            echo ""
        fi

        if [ "$has_unpushed" = true ]; then
            echo "Unpushed commits in:"
            echo "$unpushed_check" | while read -r repo; do
                [ -n "$repo" ] && echo "  - $repo"
            done
            echo ""
        fi

        echo "These changes will be lost if you continue."
    else
        echo "  âœ“ No uncommitted or unpushed changes found"
    fi

    # Always return 0 for set -e compatibility
    return 0
}

# Test if VM can reach github.com (for auto mode)
test_vm_connectivity() {
    local vm_ip="$1"

    echo "  Testing VM network connectivity to github.com..."
    if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${vm_ip}" "curl -s --connect-timeout 5 -I https://github.com 2>&1 | grep -q 'HTTP'" 2>> "$CAL_LOG"; then
        echo "  âœ“ VM can reach github.com directly"
        return 0
    else
        echo "  âš  VM cannot reach github.com (needs transparent proxy)"
        return 1
    fi
}

# Check if host SSH server is available (required for transparent proxy)
check_host_ssh() {
    echo "  Checking if host SSH server is available..."

    # Check if SSH is listening on the host gateway IP
    if nc -z -w 2 "$HOST_GATEWAY" 22 2>/dev/null; then
        echo "  âœ“ Host SSH server is running"
        return 0
    else
        echo "  âš  Host SSH server not available on $HOST_GATEWAY:22"
        echo ""
        echo "  Transparent proxy requires SSH server on host Mac."
        echo "  To enable Remote Login (SSH):"
        echo "    System Settings â†’ General â†’ Sharing â†’ Remote Login (ON)"
        echo "  Or via command line:"
        echo "    sudo systemsetup -setremotelogin on"
        echo ""
        echo "  Skipping transparent proxy setup."
        echo "[$(date)] Host SSH not available on $HOST_GATEWAY:22" >> "$CAL_LOG"
        return 1
    fi
}

# Check if host has Python (required for sshuttle server side)
check_host_python() {
    echo "  Checking if host has Python (required for sshuttle)..."

    # Check for python3 first, then python
    if command -v python3 &>/dev/null; then
        local py_version
        py_version=$(python3 --version 2>&1)
        echo "  âœ“ Host has $py_version"
        return 0
    elif command -v python &>/dev/null; then
        local py_version
        py_version=$(python --version 2>&1)
        echo "  âœ“ Host has $py_version"
        return 0
    else
        echo "  âš  Python not found on host"
        echo "  sshuttle requires Python on the server side."
        echo "  macOS should have Python pre-installed. Check with:"
        echo "    python3 --version"
        echo "[$(date)] Python not found on host" >> "$CAL_LOG"
        return 1
    fi
}

# Setup SSH key in VM for transparent proxy back to host
# Note: sshuttle needs full SSH access (runs Python on server)
setup_vm_ssh_key() {
    local vm_ip="$1"

    echo "  Setting up VM SSH key for transparent proxy..."

    # Check if host SSH is available first
    if ! check_host_ssh; then
        return 1
    fi

    # Check if host has Python (required for sshuttle)
    if ! check_host_python; then
        return 1
    fi

    # Check if VM already has an SSH key
    local has_key
    has_key=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "[ -f ~/.ssh/id_ed25519 ] && echo yes || echo no" 2>> "$CAL_LOG")

    if [ "$has_key" = "yes" ]; then
        echo "  âœ“ VM SSH key already exists"
    else
        echo "  Generating SSH key in VM..."
        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "${VM_USER}@${vm_ip}" "ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519 -N '' -C 'cal-vm-proxy' >/dev/null 2>&1" 2>> "$CAL_LOG"
        echo "  âœ“ VM SSH key generated"
    fi

    # Get the VM's public key
    local vm_pubkey
    vm_pubkey=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "cat ~/.ssh/id_ed25519.pub" 2>> "$CAL_LOG")

    if [ -z "$vm_pubkey" ]; then
        echo "  âš  Could not retrieve VM public key"
        echo "[$(date)] Failed to retrieve VM public key from $vm_ip" >> "$CAL_LOG"
        return 1
    fi

    # Get the key fingerprint for comparison (more reliable than comment)
    local vm_key_fp
    vm_key_fp=$(echo "$vm_pubkey" | ssh-keygen -lf - 2>/dev/null | awk '{print $2}')

    if [ -z "$vm_key_fp" ]; then
        echo "  âš  Could not calculate key fingerprint"
        echo "[$(date)] Failed to calculate fingerprint for VM key" >> "$CAL_LOG"
        return 1
    fi

    # Check if this specific key is already in host's authorized_keys (by fingerprint)
    mkdir -p ~/.ssh
    chmod 700 ~/.ssh
    touch ~/.ssh/authorized_keys
    chmod 600 ~/.ssh/authorized_keys

    local key_exists=false
    if [ -s ~/.ssh/authorized_keys ]; then
        # Check each key's fingerprint (suppress any debug output)
        while IFS= read -r line; do
            [ -z "$line" ] && continue
            [[ "$line" =~ ^# ]] && continue
            local existing_fp=""
            existing_fp=$(echo "$line" | awk '{print $1, $2}' | ssh-keygen -lf - 2>/dev/null | awk '{print $2}') 2>/dev/null
            if [ "$existing_fp" = "$vm_key_fp" ]; then
                key_exists=true
                break
            fi
        done < ~/.ssh/authorized_keys 2>/dev/null
    fi

    if [ "$key_exists" = "true" ]; then
        echo "  âœ“ VM key already in host authorized_keys (fingerprint: ${vm_key_fp:0:16}...)"
    else
        echo "  Adding VM key to host authorized_keys..."
        # sshuttle needs full SSH access (runs Python on server side)
        # The key is only accessible from the VM's local network
        echo "$vm_pubkey" >> ~/.ssh/authorized_keys
        echo "  âœ“ VM key added to host"
        echo "[$(date)] Added VM key with fingerprint $vm_key_fp" >> "$CAL_LOG"
    fi

    # Pre-populate host's SSH key in VM's known_hosts for secure connections
    echo "  Setting up host key verification in VM..."
    setup_vm_known_hosts "$vm_ip"

    # Test SSH from VM to host
    echo "  Testing VMâ†’Host SSH connection..."
    if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
           "${VM_USER}@${vm_ip}" "ssh -o StrictHostKeyChecking=yes -o ConnectTimeout=5 ${HOST_USER}@${HOST_GATEWAY} 'echo ok'" 2>> "$CAL_LOG"; then
        echo "  âœ“ VM can SSH to host (with host key verification)"
        return 0
    else
        echo "  âš  VMâ†’Host SSH test failed (tunnel may still work)"
        echo "[$(date)] VMâ†’Host SSH test failed" >> "$CAL_LOG"
        return 0
    fi
}

# Pre-populate VM's known_hosts with host's SSH key
# This enables StrictHostKeyChecking=yes for security
setup_vm_known_hosts() {
    local vm_ip="$1"

    # Get host's SSH public keys
    local host_keys
    host_keys=$(ssh-keyscan -H "$HOST_GATEWAY" 2>/dev/null)

    if [ -z "$host_keys" ]; then
        echo "  âš  Could not scan host SSH keys"
        echo "[$(date)] ssh-keyscan failed for $HOST_GATEWAY" >> "$CAL_LOG"
        return 1
    fi

    # Add host keys to VM's known_hosts
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "mkdir -p ~/.ssh && chmod 700 ~/.ssh && cat >> ~/.ssh/known_hosts" <<< "$host_keys" 2>> "$CAL_LOG"

    echo "  âœ“ Host SSH keys added to VM's known_hosts"
}

# Start transparent proxy (sshuttle) in VM
# This provides truly transparent network routing - no app configuration needed
start_transparent_proxy() {
    local vm_ip="$1"

    echo "  Checking transparent proxy (sshuttle)..."

    # Check if sshuttle is already running
    local proxy_running
    proxy_running=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "pgrep -f sshuttle >/dev/null && echo yes || echo no" 2>> "$CAL_LOG")

    if [ "$proxy_running" = "yes" ]; then
        echo "  âœ“ Transparent proxy already running"
        show_proxy_cow "$vm_ip"
        return 0
    fi

    # Check if sshuttle is installed (source Homebrew for PATH)
    local has_sshuttle
    has_sshuttle=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "eval \"\$(/opt/homebrew/bin/brew shellenv)\" 2>/dev/null; command -v sshuttle >/dev/null && echo yes || echo no" 2>> "$CAL_LOG")

    if [ "$has_sshuttle" != "yes" ]; then
        echo "  âš  sshuttle not installed in VM"
        echo "  Run vm-setup.sh to install sshuttle"
        echo "[$(date)] sshuttle not found in VM" >> "$CAL_LOG"
        return 1
    fi

    echo "  Starting transparent proxy (sshuttle)..."

    # Start sshuttle in background (source Homebrew for PATH)
    # Routes all traffic (0.0.0.0/0) through host, handles DNS
    # Excludes local/VM network to prevent routing loops
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "eval \"\$(/opt/homebrew/bin/brew shellenv)\" 2>/dev/null; nohup sshuttle --dns -r ${HOST_USER}@${HOST_GATEWAY} 0.0.0.0/0 -x ${HOST_GATEWAY}/32 -x 192.168.64.0/24 >> ~/.cal-proxy.log 2>&1 &" 2>> "$CAL_LOG"

    # Wait for sshuttle to start
    local count=0
    local max_wait=10
    while [ $count -lt $max_wait ]; do
        sleep 1
        count=$((count + 1))
        proxy_running=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            "${VM_USER}@${vm_ip}" "pgrep -f sshuttle >/dev/null && echo yes || echo no" 2>> "$CAL_LOG")
        if [ "$proxy_running" = "yes" ]; then
            echo "  âœ“ Transparent proxy started"
            show_proxy_cow "$vm_ip"
            return 0
        fi
    done

    echo "  âš  Transparent proxy may not have started (check ~/.cal-proxy.log in VM)"
    echo "[$(date)] sshuttle start timeout after ${max_wait}s" >> "$CAL_LOG"
    return 1
}

# Show the celebratory cow when proxy is working
show_proxy_cow() {
    local vm_ip="$1"

    # Test that proxy actually works
    local test_result
    test_result=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${vm_ip}" "curl -s --connect-timeout 5 -I https://www.google.com 2>&1 | grep -q '200' && echo yes || echo no" 2>> "$CAL_LOG")

    if [ "$test_result" = "yes" ]; then
        echo ""
        echo " ___________________________"
        echo "< Transparent proxy works! >"
        echo " ---------------------------"
        echo "        \\   ^__^"
        echo "         \\  (oo)\\_______"
        echo "            (__)\\       )\\/\\"
        echo "                ||----w |"
        echo "                ||     ||"
        echo ""
    else
        echo "[$(date)] Proxy connectivity test failed" >> "$CAL_LOG"
    fi
}

# Determine whether to enable proxy based on mode
should_enable_proxy() {
    local vm_ip="$1"

    case "$PROXY_MODE" in
        on)
            echo "  Proxy mode: on (forced)"
            return 0
            ;;
        off)
            echo "  Proxy mode: off (disabled)"
            return 1
            ;;
        auto)
            echo "  Proxy mode: auto (testing connectivity...)"
            if test_vm_connectivity "$vm_ip"; then
                echo "  â†’ Network OK, transparent proxy not needed"
                return 1
            else
                echo "  â†’ Network restricted, enabling transparent proxy"
                return 0
            fi
            ;;
        *)
            echo "  âš  Invalid PROXY_MODE='$PROXY_MODE', defaulting to auto"
            PROXY_MODE="auto"
            should_enable_proxy "$vm_ip"
            ;;
    esac
}

# === INIT MODE ===
do_init() {
    echo ""
    echo "CAL Bootstrap - Initialize"
    echo "==========================="
    echo ""

    # Check upfront if we'll be deleting existing VMs
    local dev_exists=false
    local init_exists=false

    if vm_exists "$VM_DEV"; then
        dev_exists=true
    fi

    if vm_exists "$VM_INIT"; then
        init_exists=true
    fi

    # Offer to replace cal-init with current cal-dev before proceeding
    if [ "$init_exists" = true ] && [ "$dev_exists" = true ]; then
        if [ "$SKIP_CONFIRM" = false ]; then
            echo "Do you want to replace $VM_INIT with current $VM_DEV? (y/N)"
            read -r -k 1 reply
            echo ""
            if [[ $reply =~ ^[Yy]$ ]]; then
                echo ""
                echo "Replacing $VM_INIT with current $VM_DEV..."

                # Stop cal-dev if running
                stop_vm "$VM_DEV"

                # Delete cal-init
                echo "  Deleting $VM_INIT..."
                "$TART" delete "$VM_INIT"

                # Clone cal-dev to cal-init
                echo "  Creating $VM_INIT from $VM_DEV..."
                "$TART" clone "$VM_DEV" "$VM_INIT"

                echo "  âœ“ $VM_INIT replaced with current $VM_DEV"
                echo ""
                exit 0
            else
                echo "Aborted. Existing VMs not modified."
                exit 0
            fi
        fi
    fi

    # If either exists, warn and check git before proceeding
    if [ "$dev_exists" = true ] || [ "$init_exists" = true ]; then
        echo "âš ï¸  WARNING: Existing VMs will be deleted!"
        echo ""

        if [ "$dev_exists" = true ] && [ "$init_exists" = true ]; then
            echo "Initializing will DELETE both $VM_DEV and $VM_INIT."
        elif [ "$dev_exists" = true ]; then
            echo "Initializing will DELETE $VM_DEV."
        else
            echo "Initializing will DELETE $VM_INIT."
        fi

        echo "All data and changes will be permanently lost."
        echo ""

        # Check for git changes in cal-dev if it exists
        if [ "$dev_exists" = true ]; then
            local we_started_vm=false
            local vm_ip=""

            # Start VM if not running to check for changes
            if ! vm_running "$VM_DEV"; then
                echo "Starting $VM_DEV to check for uncommitted changes..."
                if start_vm_background "$VM_DEV"; then
                    we_started_vm=true
                    vm_ip="$VM_IP"
                else
                    echo "  âš  Could not start VM to check for git changes"
                    echo "  Proceeding without git check..."
                fi
            else
                vm_ip=$("$TART" ip "$VM_DEV" 2>/dev/null || echo "")
            fi

            # Check for git changes if VM is running
            if [ -n "$vm_ip" ]; then
                check_vm_git_changes "$VM_DEV" "$vm_ip"
            fi

            # Stop VM if we started it just for the git check
            if [ "$we_started_vm" = true ]; then
                echo ""
                echo "Stopping $VM_DEV..."
                stop_vm "$VM_DEV"
                CLEANUP_VM=false
            fi
        fi

        # Get confirmation for the entire operation
        if [ "$SKIP_CONFIRM" = false ]; then
            echo ""
            if [ "$dev_exists" = true ] && [ "$init_exists" = true ]; then
                echo "Delete $VM_DEV and $VM_INIT, then re-initialize? (y/N)"
            elif [ "$dev_exists" = true ]; then
                echo "Delete $VM_DEV and re-initialize? (y/N)"
            else
                echo "Delete $VM_INIT and re-initialize? (y/N)"
            fi
            read -r -k 1 reply
            echo ""
            if [[ ! $reply =~ ^[Yy]$ ]]; then
                echo "Aborted initialization"
                exit 1
            fi
        fi

        # Delete existing VMs
        if [ "$dev_exists" = true ]; then
            stop_vm "$VM_DEV"
            echo "  Deleting $VM_DEV..."
            "$TART" delete "$VM_DEV"
        fi

        if [ "$init_exists" = true ]; then
            stop_vm "$VM_INIT"
            echo "  Deleting $VM_INIT..."
            "$TART" delete "$VM_INIT"
        fi

        echo ""
    fi

    # Step 1: Create cal-clean from base image
    echo "Step 1: Create $VM_CLEAN"
    if vm_exists "$VM_CLEAN"; then
        echo "  $VM_CLEAN already exists, skipping"
    else
        echo "  Cloning from ghcr.io/cirruslabs/macos-sequoia-base:latest..."
        echo "  (This downloads ~25GB, may take a while)"
        "$TART" clone ghcr.io/cirruslabs/macos-sequoia-base:latest "$VM_CLEAN"
        echo "  Setting VM resources (4 CPU, 8GB RAM, 80GB disk)..."
        "$TART" set "$VM_CLEAN" --cpu 4 --memory 8192 --disk-size 80
        echo "  $VM_CLEAN created"
    fi

    # Step 2: Create cal-dev from cal-clean
    echo ""
    echo "Step 2: Create $VM_DEV"
    echo "  Cloning from $VM_CLEAN..."
    "$TART" clone "$VM_CLEAN" "$VM_DEV"
    echo "  $VM_DEV created"
    
    # Step 3: Start cal-dev and setup
    echo ""
    echo "Step 3: Setup $VM_DEV"
    if ! start_vm_background "$VM_DEV"; then
        echo "  Failed to start VM"
        exit 1
    fi
    
    # Step 4: Setup SSH keys (hostâ†’VM)
    echo ""
    echo "Step 4: Setup SSH keys (hostâ†’VM)"
    setup_ssh_keys "$VM_IP"

    # Step 5: Setup proxy for network access
    echo ""
    echo "Step 5: Setup network access"
    local proxy_enabled=false
    local bootstrap_proxy_started=false

    if should_enable_proxy "$VM_IP"; then
        echo "  Proxy mode enabled, setting up VMâ†’Host SSH..."
        if setup_vm_ssh_key "$VM_IP"; then
            proxy_enabled=true
            echo "  âœ“ VMâ†’Host SSH ready"

            # Start bootstrap SOCKS proxy for package installation
            # (sshuttle isn't installed yet, so use SSH -D tunnel)
            echo ""
            echo "Step 5.5: Start bootstrap proxy for package installation"
            if start_bootstrap_proxy "$VM_IP"; then
                bootstrap_proxy_started=true
            else
                echo "  âš  Bootstrap proxy failed, will try direct connection"
            fi
        else
            echo "  âš  VMâ†’Host SSH setup failed, will try direct connection"
        fi
    else
        echo "  âœ“ Direct network connection available"
    fi

    # Step 6: Setup scripts folder first
    echo ""
    echo "Step 6: Setup scripts folder"
    setup_scripts_folder "$VM_IP"

    # Step 7: Run vm-setup from ~/scripts
    # Pass proxy flag so vm-setup knows to use SOCKS proxy env vars
    echo ""
    echo "Step 7: Install tools"
    run_vm_setup "$VM_IP" "$bootstrap_proxy_started"

    # Allow time for filesystem sync before reboot
    sleep 2

    # Step 7.5: Clean up bootstrap proxy and start sshuttle
    if [ "$bootstrap_proxy_started" = "true" ]; then
        echo ""
        echo "Step 7.5: Switch to transparent proxy (sshuttle)"
        stop_bootstrap_proxy "$VM_IP"
        start_transparent_proxy "$VM_IP" || echo "  âš  sshuttle start failed (see logs)"
    elif [ "$proxy_enabled" = "true" ]; then
        # Proxy was requested but bootstrap failed - try sshuttle anyway
        echo ""
        echo "Step 7.5: Start transparent proxy (sshuttle)"
        start_transparent_proxy "$VM_IP" || echo "  âš  sshuttle start failed (see logs)"
    fi

    # Step 8: Reboot VM to apply .zshrc configuration
    echo ""
    echo "Step 8: Reboot VM to apply configuration"
    echo "  Stopping VM..."
    "$TART" stop "$VM_DEV" 2>/dev/null || true
    kill "$TART_PID" 2>/dev/null || true
    sleep 2
    
    echo "  Restarting VM..."
    if ! start_vm_background "$VM_DEV"; then
        echo "  Failed to restart VM"
        exit 1
    fi

    # Restart proxy after reboot if it was enabled
    if [ "$proxy_enabled" = "true" ] || [ "$bootstrap_proxy_started" = "true" ]; then
        echo "  Restarting transparent proxy..."
        start_transparent_proxy "$VM_IP" || echo "  âš  Proxy restart failed"
    fi

    # Step 9: Open login shell for agent authentication
    # The .zshrc first-run check will automatically run vm-auth.sh
    echo ""
    echo "============================================"
    echo "Agent Authentication"
    echo "============================================"
    echo ""
    echo "Opening login shell in VM (vm-auth.sh will run automatically)..."
    echo ""

    # SSH into VM with login shell - .zshrc will:
    # 1. Unlock keychain
    # 2. Detect first-run flag and run vm-auth.sh
    # 3. Clear first-run flag
    ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${VM_IP}" "TERM=xterm-256color /opt/homebrew/bin/tmux new-session -A -s setup 'zsh -l'"

    echo ""
    echo "Continuing with setup..."

    # Step 10: Create cal-init
    echo ""
    echo "Step 10: Create $VM_INIT snapshot"

    # Stop VM first
    CLEANUP_VM=false
    echo "  Stopping $VM_DEV..."
    "$TART" stop "$VM_DEV" 2>/dev/null || true
    kill "$TART_PID" 2>/dev/null || true
    sleep 2

    # Create cal-init (already deleted upfront if it existed)
    echo "  Creating $VM_INIT from $VM_DEV..."
    "$TART" clone "$VM_DEV" "$VM_INIT"
    echo "  $VM_INIT created"
    
    echo ""
    echo "Bootstrap complete!"
    echo ""
    echo "VMs created:"
    printf "  %-17s - Base macOS image\n" "$VM_CLEAN"
    printf "  %-17s - Development VM (use this)\n" "$VM_DEV"
    printf "  %-17s - Snapshot with tools configured\n" "$VM_INIT"
    echo ""
    echo "Next: Run './cal-bootstrap --run' to start developing"
}

# === RUN MODE ===
do_run() {
    echo ""
    echo "CAL Bootstrap - Run"
    echo "===================="
    echo ""
    
    local vm_to_run="$VM_DEV"
    
    # Check if VM exists
    if ! vm_exists "$vm_to_run"; then
        echo "$vm_to_run does not exist."
        echo ""
        echo "Run './cal-bootstrap --init' to set up the environment."
        exit 1
    fi
    
    # If already running, just SSH in
    if vm_running "$vm_to_run"; then
        echo "$vm_to_run is already running."
        VM_IP=$("$TART" ip "$vm_to_run" 2>/dev/null || echo "")
        if [ -n "$VM_IP" ]; then
            echo ""
            # Setup and start transparent proxy if needed
            if should_enable_proxy "$VM_IP"; then
                # Ensure VM SSH key is set up (idempotent - safe to run multiple times)
                if setup_vm_ssh_key "$VM_IP"; then
                    start_transparent_proxy "$VM_IP" || echo "  âš  Transparent proxy failed to start (see ~/.cal-bootstrap.log)"
                else
                    echo "  âš  Skipping transparent proxy (setup failed)"
                fi
            fi
            unlock_keychain "$VM_IP"
            echo ""
            echo "Connecting via SSH with tmux..."
            echo "ðŸ’¡ tmux session 'cal' (Ctrl+b d to detach, Ctrl+b ? for help)"
            echo ""
            ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                "${VM_USER}@${VM_IP}" "TERM=xterm-256color /opt/homebrew/bin/tmux new-session -A -s cal"
        else
            echo "Could not get VM IP address."
            exit 1
        fi
        exit 0
    fi
    
    # Start VM
    if ! start_vm_background "$vm_to_run"; then
        echo "Failed to start VM"
        exit 1
    fi
    
    # Don't cleanup on success
    CLEANUP_VM=false

    echo ""
    echo "$vm_to_run is running (PID: $TART_PID)"

    # Setup and start transparent proxy if needed
    if should_enable_proxy "$VM_IP"; then
        # Ensure VM SSH key is set up (idempotent - safe to run multiple times)
        if setup_vm_ssh_key "$VM_IP"; then
            start_transparent_proxy "$VM_IP" || echo "  âš  Transparent proxy failed to start (see ~/.cal-bootstrap.log)"
        else
            echo "  âš  Skipping transparent proxy (setup failed)"
        fi
    fi

    # Unlock keychain for SSH access
    unlock_keychain "$VM_IP"

    echo ""
    echo "VNC:   open vnc://${VM_IP}"
    echo "Stop:  $TART stop $vm_to_run"
    echo ""
    echo "ðŸ’¡ If agent login fails, use Screen Sharing (standard mode, not High Performance):"
    echo "   open vnc://${VM_IP} â†’ Authenticate agent â†’ Return to terminal"
    echo ""
    echo "Connecting via SSH with tmux..."
    echo "ðŸ’¡ tmux session 'cal' (Ctrl+b d to detach, Ctrl+b ? for help)"
    echo ""
    
    # SSH into the VM with tmux (always)
    ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${VM_IP}" "TERM=xterm-256color /opt/homebrew/bin/tmux new-session -A -s cal"
}

# === STOP MODE ===
do_stop() {
    echo ""
    echo "CAL Bootstrap - Stop"
    echo "===================="
    echo ""

    if ! vm_exists "$VM_DEV"; then
        echo "$VM_DEV does not exist."
        exit 1
    fi

    if ! vm_running "$VM_DEV"; then
        echo "$VM_DEV is not running."
        exit 0
    fi

    echo "Stopping $VM_DEV..."
    "$TART" stop "$VM_DEV"
    echo ""
    echo "$VM_DEV stopped."
}

# === RESTART MODE ===
do_restart() {
    echo ""
    echo "CAL Bootstrap - Restart"
    echo "========================="
    echo ""

    if ! vm_exists "$VM_DEV"; then
        echo "$VM_DEV does not exist."
        echo ""
        echo "Run './cal-bootstrap --init' to set up the environment."
        exit 1
    fi

    # Stop if running
    if vm_running "$VM_DEV"; then
        echo "Stopping $VM_DEV..."
        "$TART" stop "$VM_DEV"
        sleep 2
        echo ""
    fi

    # Start VM
    if ! start_vm_background "$VM_DEV"; then
        echo "Failed to start VM"
        exit 1
    fi

    # Don't cleanup on success
    CLEANUP_VM=false

    echo ""
    echo "$VM_DEV is running (PID: $TART_PID)"

    # Setup and start transparent proxy if needed
    if should_enable_proxy "$VM_IP"; then
        # Ensure VM SSH key is set up (idempotent - safe to run multiple times)
        if setup_vm_ssh_key "$VM_IP"; then
            start_transparent_proxy "$VM_IP" || echo "  âš  Transparent proxy failed to start (see ~/.cal-bootstrap.log)"
        else
            echo "  âš  Skipping transparent proxy (setup failed)"
        fi
    fi

    # Unlock keychain for SSH access
    unlock_keychain "$VM_IP"

    echo ""
    echo "VNC:   open vnc://${VM_IP}"
    echo "Stop:  $TART stop $VM_DEV"
    echo ""
    echo "ðŸ’¡ If agent login fails, use Screen Sharing (standard mode, not High Performance):"
    echo "   open vnc://${VM_IP} â†’ Authenticate agent â†’ Return to terminal"
    echo ""
    echo "Connecting via SSH with tmux..."
    echo "ðŸ’¡ tmux session 'cal' (Ctrl+b d to detach, Ctrl+b ? for help)"
    echo ""

    # SSH into the VM with tmux (always)
    ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
        "${VM_USER}@${VM_IP}" "TERM=xterm-256color /opt/homebrew/bin/tmux new-session -A -s cal"
}

# === SNAPSHOT MODE ===
do_snapshot() {
    local action="$1"
    local name="$2"
    
    echo ""
    echo "CAL Bootstrap - Snapshot"
    echo "========================="
    echo ""
    
    case "$action" in
        create)
            if [ -z "$name" ]; then
                echo "Usage: ./cal-bootstrap --snapshot create <name>"
                exit 1
            fi
            
            # Stop VM if running
            stop_vm "$VM_DEV"

            local snapshot_name="$name"

            if vm_exists "$snapshot_name"; then
                if [ "$SKIP_CONFIRM" = true ]; then
                    "$TART" delete "$snapshot_name"
                else
                    echo "Snapshot $snapshot_name already exists. Replace? (y/N)"
                    read -r -k 1 reply
                    echo ""
                    if [[ $reply =~ ^[Yy]$ ]]; then
                        "$TART" delete "$snapshot_name"
                    else
                        echo "Aborted"
                        exit 1
                    fi
                fi
            fi
            
            echo "Creating snapshot: $snapshot_name"
            "$TART" clone "$VM_DEV" "$snapshot_name"
            echo ""
            echo "Snapshot created: $snapshot_name"
            echo ""
            echo "Restore with: ./cal-bootstrap --snapshot restore $name"
            ;;
            
        restore)
            if [ -z "$name" ]; then
                echo "Usage: ./cal-bootstrap --snapshot restore <name>"
                echo ""
                do_snapshot list
                exit 1
            fi

            # Resolve short name to full name
            local restore_from
            restore_from=$(resolve_vm_name "$name")

            if [ -z "$restore_from" ]; then
                echo "VM '$name' not found"
                echo ""
                do_snapshot list
                exit 1
            fi

            # Can't restore from cal-dev to cal-dev
            if [ "$restore_from" = "$VM_DEV" ]; then
                echo "Cannot restore $VM_DEV from itself"
                exit 1
            fi

            # Check if cal-dev exists (early exit if missing)
            if ! vm_exists "$VM_DEV"; then
                echo "âš ï¸  $VM_DEV does not exist."
                echo ""
                echo "Cannot restore to a non-existent VM."
                echo ""
                echo "You can:"
                echo "  1. Re-run: ./scripts/cal-bootstrap --init"
                echo "  2. Or create manually: tart clone cal-clean $VM_DEV"
                echo ""
                exit 1
            fi

            # Always check for git changes - boot VM if needed
            local we_started_vm=false
            local vm_ip=""

            # Start VM if not running
            if ! vm_running "$VM_DEV"; then
                echo "Starting $VM_DEV to check for uncommitted changes..."
                if start_vm_background "$VM_DEV"; then
                    we_started_vm=true
                    vm_ip="$VM_IP"
                else
                    echo "  âš  Could not start VM to check for git changes"
                    echo "  Proceeding without git check..."
                fi
            else
                vm_ip=$("$TART" ip "$VM_DEV" 2>/dev/null || echo "")
            fi

            # Check for git changes if VM is running
            if [ -n "$vm_ip" ]; then
                check_vm_git_changes "$VM_DEV" "$vm_ip"
            fi

            # Stop VM if we started it just for the git check
            if [ "$we_started_vm" = true ]; then
                echo ""
                echo "Stopping $VM_DEV..."
                stop_vm "$VM_DEV"
                CLEANUP_VM=false
            fi

            # Single confirmation prompt (after showing git warnings if any)
            if [ "$SKIP_CONFIRM" = false ]; then
                echo ""
                echo "This will replace $VM_DEV with $restore_from"
                echo "All changes in $VM_DEV will be lost!"
                echo ""
                echo "Continue? (y/N)"
                read -r -k 1 reply
                echo ""
                if [[ ! $reply =~ ^[Yy]$ ]]; then
                    echo "Aborted"
                    exit 1
                fi
            fi

            # Stop and delete current VM
            stop_vm "$VM_DEV"

            # Delete VM
            if vm_exists "$VM_DEV"; then
                echo "Deleting $VM_DEV..."
                if ! "$TART" delete "$VM_DEV"; then
                    echo ""
                    echo "âš ï¸  Failed to delete $VM_DEV"
                    echo ""
                    echo "This can happen if:"
                    echo "  â€¢ VM is in an inconsistent state"
                    echo "  â€¢ Tart is holding a lock on the VM"
                    echo "  â€¢ Another process is using the VM"
                    echo ""
                    echo "You may need to delete it manually:"
                    echo "  tart delete $VM_DEV"
                    echo ""
                    echo "Or restart your machine if Tart is locked."
                    echo ""
                    echo "Aborting restore."
                    exit 1
                fi
            fi

            # Restore from snapshot
            echo "Restoring from $restore_from..."
            "$TART" clone "$restore_from" "$VM_DEV"
            
            echo ""
            echo "Restored $VM_DEV from $restore_from"
            echo ""
            
            # Give different instructions based on what was restored
            if [ "$restore_from" = "$VM_CLEAN" ]; then
                echo "âš ï¸  Restored from clean base image (no tools installed)"
                echo ""
                echo "Run './cal-bootstrap --init' to set up tools and agents"
            else
                echo "Run './cal-bootstrap --run' to start the VM"
            fi
            ;;
            
        list)
            # Check if jq is available (required for JSON parsing)
            if ! command -v jq &>/dev/null; then
                echo "Error: jq is required for listing VMs with size information"
                echo ""
                echo "Install with: brew install jq"
                echo ""
                exit 1
            fi

            # Check for short name collisions (use text output for this)
            local collision_check
            collision_check=$("$TART" list 2>/dev/null | awk 'NR==1 {next} {
                full_name = $2
                source = $1

                # Create short name
                short_name = full_name
                if (source == "OCI") {
                    gsub(/ghcr.io\/cirruslabs\/macos-/, "", short_name)
                    if (match(short_name, /@sha256:/)) {
                        short_name = substr(short_name, 1, RSTART-1) "-digest"
                    }
                }

                print short_name
            }' | sort | uniq -d)

            if [ -n "$collision_check" ]; then
                echo "âš ï¸  WARNING: Short name collisions detected!"
                echo "   Use full names for these VMs:"
                echo ""
            fi

            # List VMs using JSON for accurate size data
            local json_output
            json_output=$("$TART" list --format json 2>&1)

            if [ $? -ne 0 ] || [ -z "$json_output" ]; then
                echo "Error: Failed to get VM list from tart"
                echo ""
                echo "Try running: tart list"
                echo ""
                exit 1
            fi

            local parsed_data
            parsed_data=$(echo "$json_output" | jq -r '.[] | "\(.Name)|\(.Source)|\(.Size)|\(.State)"' 2>&1)

            if [ $? -ne 0 ]; then
                echo "Error: Failed to parse VM data"
                echo ""
                echo "This may indicate a problem with tart or jq."
                echo "Try running: tart list --format json"
                echo ""
                exit 1
            fi

            echo "$parsed_data" | awk -F'|' -v collisions="$collision_check" '
                BEGIN {
                    # Build collision map
                    split(collisions, coll_array, "\n")
                    for (i in coll_array) {
                        collision_map[coll_array[i]] = 1
                    }
                    total_size = 0
                }
                {
                    full_name = $1
                    source = $2
                    size = $3
                    state = $4

                    # Add to total
                    total_size += size

                    # Create short name for display
                    short_name = full_name
                    if (source == "OCI") {
                        gsub(/ghcr.io\/cirruslabs\/macos-/, "", short_name)
                        if (match(short_name, /@sha256:/)) {
                            short_name = substr(short_name, 1, RSTART-1) "-digest"
                        }
                    }

                    # Determine which name to show
                    display_name = (short_name in collision_map) ? full_name : short_name

                    # Format size with GB suffix and space
                    size_str = size " GB"

                    # If name is too long, put it on its own line
                    if (length(display_name) > 40) {
                        printf "  %s\n", display_name
                        printf "  %-40s %-10s (%s)\n", "", size_str, state
                    } else {
                        printf "  %-40s %-10s (%s)\n", display_name, size_str, state
                    }
                }
                END {
                    print ""
                    printf "Total: %d GB\n", total_size
                }'

            echo ""
            exit 0
            ;;
            
        delete)
            if [ -z "$name" ]; then
                echo "Usage: ./cal-bootstrap --snapshot delete <name>"
                echo ""
                do_snapshot list
                exit 1
            fi
            
            # Resolve short name to full name
            local vm_to_delete
            vm_to_delete=$(resolve_vm_name "$name")

            if [ -z "$vm_to_delete" ]; then
                echo "VM '$name' not found"
                echo ""
                do_snapshot list
                exit 1
            fi

            # Check for git changes before deleting (skip only for cal-clean base image)
            if [ "$vm_to_delete" != "$VM_CLEAN" ]; then
                local we_started_vm=false
                local vm_ip=""

                # Start VM if not running to check for changes
                if ! vm_running "$vm_to_delete"; then
                    echo "Starting $vm_to_delete to check for uncommitted changes..."
                    if start_vm_background "$vm_to_delete"; then
                        we_started_vm=true
                        vm_ip="$VM_IP"
                    else
                        echo "  âš  Could not start VM to check for git changes"
                        echo "  Proceeding without git check..."
                    fi
                else
                    vm_ip=$("$TART" ip "$vm_to_delete" 2>/dev/null || echo "")
                fi

                # Check for git changes if VM is running
                if [ -n "$vm_ip" ]; then
                    check_vm_git_changes "$vm_to_delete" "$vm_ip"
                    echo ""
                fi

                # Stop VM if we started it just for the git check
                if [ "$we_started_vm" = true ]; then
                    echo "Stopping $vm_to_delete..."
                    stop_vm "$vm_to_delete"
                    CLEANUP_VM=false
                    echo ""
                fi
            fi

            # Stop the VM before deletion (if still running)
            stop_vm "$vm_to_delete"

            # Confirm (with extra warning for system VMs)
            if [ "$SKIP_CONFIRM" = false ]; then
                if [ "$vm_to_delete" = "$VM_DEV" ]; then
                    echo "âš ï¸  WARNING: Deleting your working VM!"
                    echo ""
                    echo "This will delete $vm_to_delete permanently."
                    echo "You may want to use restore instead to reset state."
                    echo ""
                elif [ "$vm_to_delete" = "$VM_CLEAN" ]; then
                    echo "âš ï¸  WARNING: Deleting the clean base image!"
                    echo ""
                    echo "This will delete $vm_to_delete permanently."
                    echo "You'll need to re-download (~25GB) to recreate it."
                    echo ""
                elif [ "$vm_to_delete" = "$VM_INIT" ]; then
                    echo "âš ï¸  WARNING: Deleting the initialized snapshot!"
                    echo ""
                    echo "This will delete $vm_to_delete permanently."
                    echo "You'll need to run --init again to recreate it."
                    echo ""
                fi
                echo "Delete $vm_to_delete?"
                echo ""
                echo "Continue? (y/N)"
                read -r -k 1 reply
                echo ""
                if [[ ! $reply =~ ^[Yy]$ ]]; then
                    echo "Aborted"
                    exit 1
                fi
            fi
            
            echo "Deleting $vm_to_delete..."
            "$TART" delete "$vm_to_delete"
            echo ""
            echo "Deleted: $vm_to_delete"
            ;;
            
        *)
            echo "Usage: ./cal-bootstrap --snapshot <list|create|restore|delete> [name]"
            echo ""
            echo "Examples:"
            echo "  ./cal-bootstrap --snapshot list"
            echo "  ./cal-bootstrap --snapshot create before-refactor"
            echo "  ./cal-bootstrap --snapshot restore before-refactor"
            echo "  ./cal-bootstrap --snapshot delete before-refactor"
            exit 1
            ;;
    esac
}

# === MAIN ===

# Parse arguments
MODE=""
SKIP_CONFIRM=false
SNAPSHOT_ACTION=""
SNAPSHOT_NAME=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --init|-i)
            MODE="init"
            shift
            ;;
        --run)
            MODE="run"
            shift
            ;;
        --restart|-r)
            MODE="restart"
            shift
            ;;
        --stop|-s)
            MODE="stop"
            shift
            ;;
        --snapshot|-S)
            MODE="snapshot"
            shift
            SNAPSHOT_ACTION="${1:-}"
            [[ $# -gt 0 ]] && shift
            SNAPSHOT_NAME="${1:-}"
            [[ $# -gt 0 ]] && shift
            ;;
        --socks|--proxy)
            shift
            PROXY_MODE="${1:-auto}"
            if [[ ! "$PROXY_MODE" =~ ^(on|off|auto)$ ]]; then
                echo "Error: --proxy must be 'on', 'off', or 'auto'"
                echo "Got: '$PROXY_MODE'"
                exit 1
            fi
            shift
            ;;
        --yes|-y)
            SKIP_CONFIRM=true
            shift
            ;;
        --help|-h)
            echo "CAL Bootstrap - VM Environment Setup"
            echo ""
            echo "Usage: ./cal-bootstrap [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --init, -i                    Initialize VM environment"
            echo "  --run                         Run cal-dev with tmux (default if VMs exist)"
            echo "  --restart, -r                 Restart cal-dev and connect with tmux"
            echo "  --stop, -s                    Stop cal-dev"
            echo "  --snapshot, -S list           List available snapshots"
            echo "  --snapshot, -S create <name>  Create a named snapshot"
            echo "  --snapshot, -S restore <name> Restore from a snapshot"
            echo "  --snapshot, -S delete <name>  Delete a snapshot"
            echo "  --proxy <on|off|auto>         Transparent proxy mode (default: auto)"
            echo "                                  on   - Always enable transparent proxy"
            echo "                                  off  - Disable transparent proxy"
            echo "                                  auto - Test github.com, enable if needed"
            echo "  --yes, -y                     Skip confirmation prompts"
            echo "  --help, -h                    Show this help"
            echo ""
            echo "Examples:"
            echo "  ./cal-bootstrap --init              # First-time setup"
            echo "  ./cal-bootstrap                     # Start cal-dev (auto-detects mode)"
            echo "  ./cal-bootstrap --restart           # Restart cal-dev and connect"
            echo "  ./cal-bootstrap --snapshot create pre-experiment"
            echo "  ./cal-bootstrap --snapshot restore pre-experiment"
            echo "  ./cal-bootstrap --snapshot delete pre-experiment"
            echo ""
            echo "Note: tmux is always used for persistent sessions."
            echo "      Ctrl+b d to detach, Ctrl+b ? for help"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Run './cal-bootstrap --help' for usage"
            exit 1
            ;;
    esac
done

# Find tart
TART=$(find_tart)
if [ -z "$TART" ]; then
    echo "Error: tart not found"
    echo ""
    echo "Install with: brew install cirruslabs/cli/tart"
    echo ""
    echo "Or set TART_PATH environment variable"
    exit 1
fi

# Auto-detect mode if not specified
if [ -z "$MODE" ]; then
    if vm_exists "$VM_CLEAN" && vm_exists "$VM_DEV" && vm_exists "$VM_INIT"; then
        MODE="run"
    else
        MODE="init"
    fi
    echo "Auto-detected mode: $MODE"
fi

# Execute mode
case "$MODE" in
    init)
        do_init
        ;;
    run)
        do_run
        ;;
    restart)
        do_restart
        ;;
    stop)
        do_stop
        ;;
    snapshot)
        do_snapshot "$SNAPSHOT_ACTION" "$SNAPSHOT_NAME"
        ;;
esac
